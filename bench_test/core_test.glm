// Copyright 2018 The Golem Language Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

import zork

fn fail(func, err) {
    try {
        func()
        assert(false)
    } catch e {
        //println("BenchTestError: " + err + " != " + e.error)
        assert(err == e.error)

        //println("BenchTestError: " + err + " != " + e.error)
        ////println('==============================================')
        //if err != e.error {
        //    //throw "BenchTestError: " + err + " != " + e.error
        //    println("BenchTestError: " + err + " != " + e.error)
        //    assert(false)
        //    //assert(err == e.error)
        //}
    }
}

fn testExpressions() {

	assert((2 + 3) * -4 / 10 == -2)
	assert((2*2*2*2 + 2*3*(8 - 1) + 2) / (17 - 2*2*2 - -1) == 6)

	assert(true + 'a' == 'truea')
	assert('a' + true == 'atrue')
	assert('a' + null == 'anull')
	assert(null + 'a' == 'nulla')

	fail(|| => true + null, 'TypeMismatch: Expected Number')
	fail(|| => 1 + null, 'TypeMismatch: Expected Number')
	fail(|| => null + 1, 'TypeMismatch: Expected Number')

	assert((true == 'a') == false)
	assert((3 * 7 + 4 == 5 * 5) == true)
	assert((1 != 1) == false)
	assert((1 != 2) == true)

	assert(!false == true)
	assert(!true == false)
	fail(|| => !null, 'TypeMismatch: Expected Bool')
	fail(|| => !'a', 'TypeMismatch: Expected Bool')
	fail(|| => !1, 'TypeMismatch: Expected Bool')
	fail(|| => !1.0, 'TypeMismatch: Expected Bool')

	assert(1 < 2 == true)
	assert(1 <= 2 == true)
	assert(1 > 2 == false)
	assert(1 >= 2 == false)

	assert(2 < 2 == false)
	assert(2 <= 2 == true)
	assert(2 > 2 == false)
	assert(2 >= 2 == true)

	assert(1 <=> 2 == -1)
	assert(2 <=> 2 == 0)
	assert(2 <=> 1 == 1)

	assert((true  && true) == true)
	assert((true  && false) == false)
	assert((false && true) == false)
	assert((false && 12) == false)
	fail(|| => 12 && false, 'TypeMismatch: Expected Bool')

	assert(true  || (true == true))
	assert(true  || (false == true))
	assert(false || (true == true))
	assert(false || (false == false))
	assert(true  || (12 == true))
	fail(|| => 12  || true, 'TypeMismatch: Expected Bool')

	assert(~0 == -1)
	assert(8 % 2 == 0)
	assert(8 & 2 == 0)
	assert(8 | 2 == 10)
	assert(8 ^ 2 == 10)
	assert(8 << 2 == 32)
	assert(8 >> 2 == 2)

	assert([true][0] == true)
	assert('abc'[1] == 'b')
	assert('abc'[-1] == 'c')
	fail(|| => [true][2], 'IndexOutOfBounds: 2')

	assert('abc'[1:] == 'bc')
	assert('abc'[:1] == 'a')
	assert('abcd'[1:3] == 'bc')
	assert('abcd'[1:1] == '')

	assert([6,7,8][1:] == [7,8])
	assert([6,7,8][:1] == [6])
	assert([6,7,8,9][1:3] == [7,8])
	assert([6,7,8,9][1:1] == [])

}

fn testAssignment() {
    let funcs = [
        fn () {
            let a = 1
            const b = 2
            a = a + b
            assert([3, 2] == [a, b])
        },
        fn () {
            let a = 1
            a = a + 41
            const b = a / 6
            let c = b + 3
            c = (c + a)/13
            assert([42, 7, 4] == [a, b, c])
        },
        fn () {
            let a = 1
            let b = a += 3
            let c = ~0
            c -= -2
            c <<= 4
            b *= 2
            assert([4, 8, 16] == [a, b, c])
        },
        fn () {
            let a = 1
            let b = 2
            a = b = 11
            b = a %= 4
            assert([3, 3] == [a, b])
        },
        fn () {
            let a = 10
            let b = 20
            let c = a++
            let d = b--
            assert([11, 19, 10, 20] == [a, b, c, d])

            fail(fn() {
                    let e = 'abc'
                    e++
                }, "TypeMismatch: Expected Number")
        },
        fn () {
            let a = [10]
            let b = [20]
            let c = a[0]++
            let d = b[0]--
            assert([[11], [19], 10, 20] == [a, b, c, d])

            fail(fn() {
                    let e = ['abc']
                    e[0]++
                }, "TypeMismatch: Expected Number")
        },
        fn () {
            let a = struct { x: 10 }
            let b = struct { y: 20 }
            let c = a.x++
            let d = b.y--
            assert([struct { x: 11 }, struct { y: 19 }, 10, 20] == [a, b, c, d])

            fail(fn() {
                    let e = struct { x: 'abc' }
                    e.x++
                }, "TypeMismatch: Expected Number")
        }
    ]
    for f in funcs { f(); }
}

fn testTry() {
//    println('testTry')
//
//    let funcs = [
//        fn () {
//            println('begin func 0')
//            fail(|| => 3 / 0, "DivideByZero")
//            fail(fn() {
//                    try {
//                        3 / 0
//                    } catch e2 {
//                        assert()
//                    }
//                },
//                "ArityMismatch: Expected 1 params, got 0")
//            println('end   func 0')
//        },
//        fn () {
//            println('begin func 1')
//            let a = 0
//            let b = 0
//            try {
//                3 / 0
//            } catch e {
//                a = 1
//            }
//            try {
//                3 / 0
//            } catch e {
//                b = 2
//            }
//            assert(a == 1)
//            assert(b == 2)
//            println('end   func 1')
//        },
//        fn () {
//            println('begin func 2')
//            let a = 0
//            try {
//                3 / 0
//            } catch e {
//                a = 1
//            } finally {
//                a = 2
//            }
//            assert(a == 2)
//            println('end   func 2')
//        },
//        fn () {
//            println('begin func 3')
//            let a = 0
//            //let f = fn() {
//            //    try {
//            //        3 / 0
//            //    } catch e {
//            //        return 1
//            //    } finally {
//            //        a = 2
//            //    }
//            //}
//            //let b = f()
//            //assert(b == 1)
//            //assert(a == 2)
//            println('end   func 3')
//        },
//        fn () {
//            println('begin func 4')
//            //let a = 0
//            //let f = fn() {
//            //    try {
//            //        3 / 0
//            //    } catch e {
//            //        return 1
//            //    } finally {
//            //        a = 2
//            //    }
//            //}
//            //let b = f()
//            //assert(b == 1)
//            //assert(a == 2)
//            println('end   func 4')
//        }
//        //fn () {
//        //    println('func 4')
//        //    let a = 0
//        //    let b = 0
//        //    //try {
//        //    //    try {
//        //    //        3 / 0
//        //    //    } catch e {
//        //    //        assert(1,2,3)
//        //    //    } finally {
//        //    //        a = 1
//        //    //    }
//        //    //} catch e {
//        //    //    b = 2
//        //    //}
//        //    //assert(a == 1)
//        //    //assert(b == 2)
//        //}
//        ////fn () {
//        ////    println('throw test')
//        ////    //try {
//        ////        //throw 'abcdef';
//        ////        //assert(false)
//        ////    //} catch e {
//        ////    //    println(e)
//        ////    //}
//        ////}
//    ]
//    println('len funcs ', len(funcs))
//
//    //funcs[0]()
//    //funcs[1]()
//    //funcs[2]()
//    funcs[3]()
//    funcs[4]()
//
//    //for i in range(0, len(funcs)) {
//    //    let f = funcs[i]
//    //    println('testing ', i, ': ', f)
//    //    f()
//    //}
//    
//    //for f in funcs { 
//    //    println('testing ', f)
//    //    f() 
//    //}
}

fn testFlowControl() {
    let funcs = [
        fn () {
            let a = 1; if (true) { a = 2; }
            assert(a == 2)
        },
        fn () {
            let a = 1; if (false) { a = 2; }
            assert(a == 1)
        },
        fn () {
            let a = 1; if (1 == 1) { a = 2; } else { a = 3; }; let b = 4;
            assert(a == 2 && b == 4)
        },
        fn () {
            let a = 1; if (1 == 2) { a = 2; } else { a = 3; }; const b = 4;
            assert(a == 3 && b == 4)
        },
        fn () {
            let a = true ? 3 : 4;
            let b = false ? 5 : 6;
            assert(a == 3 && b == 6)
        },
        fn () {
            let a = 1
            while (a < 3) {
                a = a + 1
            }
            assert(a == 3)
        },
        fn () {
            let a = 1
            while (a < 11) {
                if (a == 4) { a = a + 2; break; }
                a = a + 1
            }
            assert(a == 6)
        },
        fn () {
            let a = 1
            let b = 0
            while (a < 11) {
                a = a + 1
                if (a > 5) { continue; }
                b = b + 1
            }
            assert(a == 11 && b == 4)
        },
        fn () {
            let s = ''
            for i in range(0, 4) {
                switch {
                case i == 0:
                    s += 'a'

                case i == 1, i == 2:
                    s += 'b'

                default:
                    s += 'c'
                }
            }
            assert(s == 'abbc')
        },
        fn () {
            let s = ''
            for i in range(0, 4) {
                switch {
                case i == 0, i == 1:
                    s += 'a'

                case i == 2:
                    s += 'b'
                }
            }
            assert(s == 'aab')
        },
        fn () {
            let s = ''
            for i in range(0, 4) {
                switch i {
                case 0, 1:
                    s += 'a'

                case 2:
                    s += 'b'
                }
            }
            assert(s == 'aab')
        },
        fn () {
            let a = 0
            for n in [1,2,3] {
                a += n
            }
            assert(a == 6)
        }

//	code = `
//let keys = '';
//let values = 0;
//for (k, v)  in dict {'a': 1, 'b': 2, 'c': 3} {
//    keys += k;
//    values += v;
//}
//assert(keys == 'bac');
//assert(values == 6);
//`
//	mod = testCompile(t, code)
//	interpret([]*g.Module{mod})
//
//	code = `
//let entries = '';
//for e in dict {'a': 1, 'b': 2, 'c': 3} {
//    entries += str(e);
//}
//assert(entries == '(b, 2)(a, 1)(c, 3)');
//`
//	mod = testCompile(t, code)
//	interpret([]*g.Module{mod})
//
//	code = `
//let keys = '';
//let values = 0;
//for (k, v)  in [('a', 1), ('b', 2), ('c', 3)] {
//    keys += k;
//    values += v;
//}
//assert(keys == 'abc');
//assert(values == 6);
//`
//	mod = testCompile(t, code)
//	interpret([]*g.Module{mod})
//
//	code = "for (k, v)  in [1, 2, 3] {}"
//	fail(t, code,
//		g.TypeMismatchError("Expected Tuple"),
//		[]string{"    at foo.glm:1"})
//
//	code = "for (a, b, c)  in [('a', 1), ('b', 2), ('c', 3)] {}"
//	fail(t, code,
//		g.InvalidArgumentError("Expected Tuple of length 3"),
//		[]string{"    at foo.glm:1"})
//        }
    ]
    for f in funcs { f(); }
}

fn testFunc() {

    let a = fn(x) { x; }
    let b = a(1)
    assert(b == 1)

    //------------------------------------------

    a = fn() { }
    b = fn(x) { x; }
    let c = fn(x, y) { let z = 4; x * y * z; }
    let d = a()
    let e = b(1)
    let f = c(b(2), 3)
    assert([null, 1, 24] == [d, e, f])

    //------------------------------------------

    let fibonacciGenerator = fn() {
        let x = 1
        let y = 1
        return fn() {
            let z = x
            x = y
            y = x + z
            return z
        }
    }
    let fg = fibonacciGenerator()
    let list = []
    for i in range(0, 10) {
        list.add(fg())
    }
    assert([1, 1, 2, 3, 5, 8, 13, 21, 34, 55] == list)

    //------------------------------------------

    let foo = fn(n) {
        let bar = fn(x) {
            return x * (x - 1)
        }
        return bar(n) + bar(n-1)
    }
    assert(32 == foo(5))

    //------------------------------------------

	fail(|| => 1/0, 'DivideByZero')
}

fn testCapture() {

    const accumGen = fn(n) {
        return fn(i) {
            n = n + i
            return n
        }
    }
    const a = accumGen(3)
    const x = a(2)
    const y = a(7)
    assert([5, 12] == [x, y])

    //---------------------

    let z = 2
    const acc2 = fn(n) {
        return fn(i) {
            n = n + i
            n = n + z
            return n
        }
    }
    const b = acc2(3)
    let i = b(2)
    z = 0
    let j = b(1)
    assert([0, 7, 8] == [z, i, j])

    const m = 123
    const n = 456

    fn foo() {
        assert(n == 456)
        assert(m == 123)
    }
    foo()

    //---------------------

    const cap = 1
    let f1 = || => cap
    let f2 = || => cap
    assert([1, 1] == [f1(), f2()])
}

fn testNamedFunc() {
    fn a() {
        return b()
    }
    fn b() {
        return 42
    }
    assert(a() == 42)
}

fn testLambda() {
    let z = 5
    let a = || => 3
    let b = |x| => x * x
    let c = |x, y| => (x + y)*z
    assert(a() == 3)
    assert(b(2) == 4)
    assert(c(1, 2) == 15)
}

fn testNull() {

    assert(null == null)
    assert(null != 1)
    assert(1 != null)

    fail(|| => freeze(null), "NullValue")
    fail(|| => frozen(null), "NullValue")
    fail(|| => iter(null), "NullValue")
    fail(|| => len(null), "NullValue")
    fail(|| => range(null, null), "NullValue")
    assert('null' == str(null))
    fail(|| => type(null), "NullValue")

    fail(|| => fields(null), "NullValue")
    fail(|| => hasField(null, 'bogus'), "NullValue")
    fail(|| => getField(null, 'bogus'), "NullValue")
    fail(|| => setField(null, 'bogus', null), "NullValue")

   // try {
   //     println('type: ', type(null))
   // } catch e {
   //     println(e.error)
   // }
}

fn testStr() {

    let s = '\u{1f496}\u{2665}\u{24}'
    assert(s[0] == '💖')
    assert(s[1] == '♥')
    assert(s[2] == '$')
//
//		"let s = `\n" +
//			"ab\n" +
//			"cd\n" +
//			"efgh\n" +
//			"`\n" +
//			"\tassert(s[1:3] == 'ab')\n" +
//			"\tassert(s[4:6] == 'cd')\n" +
//			"\tassert(s[7:-1] == 'efgh')"
//---------------------------------------------

//	assert(struct{a: 1} has 'a' == true)
//	assert(struct{a: 1} has 'b' == false)
//    assert('abc'.contains('b'))
//    assert(!'abc'.contains('z'))
//    assert('abc'.index('b') == 1)
//    assert('abc'.index('z') == -1)
//    assert('abc'.startsWith('a'))
//    assert(!'abc'.startsWith('z'))
//    assert('abc'.endsWith('c'))
//    assert(!'abc'.endsWith('z'))
//    assert('aaa'.replace('a', 'z') == 'zzz')
//    assert('aaa'.replace('a', 'z', 2) == 'zza')
//    assert('aaa'.replace('a', 'z', 0) == 'aaa')
//    assert('aaa'.replace('a', 'z', -1) == 'zzz')
//    assert('a,b,c'.split(',') == ['a','b','c'])
//
//    assert('abcabc'.lastIndex('ab') == 3)
//    assert('abc'.lastIndex('z') == -1)
//
//    fn ext(s) {
//        let n = s.lastIndex('.')
//        return n == -1 ? '' : s[n:]
//    }
//    assert(ext('foo') == '')
//    assert(ext('foo.txt') == '.txt')
//
//	failMsg(|| => 'abc'.contains(), 'ArityMismatch', 'Expected 1 params, got 0')
//	failMsg(|| => 'abc'.contains(1), 'TypeMismatch', 'Expected Str')
//
//	failMsg(|| => 'abc'.index(), 'ArityMismatch', 'Expected 1 params, got 0')
//	failMsg(|| => 'abc'.index(1), 'TypeMismatch', 'Expected Str')
//	failMsg(|| => 'abc'.lastIndex(), 'ArityMismatch', 'Expected 1 params, got 0')
//	failMsg(|| => 'abc'.lastIndex(1), 'TypeMismatch', 'Expected Str')
//
//	failMsg(|| => 'abc'.startsWith(), 'ArityMismatch', 'Expected 1 params, got 0')
//	failMsg(|| => 'abc'.startsWith(1), 'TypeMismatch', 'Expected Str')
//
//	failMsg(|| => 'abc'.endsWith(), 'ArityMismatch', 'Expected 1 params, got 0')
//	failMsg(|| => 'abc'.endsWith(1), 'TypeMismatch', 'Expected Str')
//
//	failMsg(|| => 'abc'.replace(), 'ArityMismatch', 'Expected at least 2 params, got 0')
//	failMsg(|| => 'abc'.replace(1,2,3,4), 'ArityMismatch', 'Expected at most 3 params, got 4')
//	failMsg(|| => 'abc'.replace(0, 'a'), 'TypeMismatch', 'Expected Str')
//	failMsg(|| => 'abc'.replace('a', 0), 'TypeMismatch', 'Expected Str')
//	failMsg(|| => 'abc'.replace('a', 'b', 'c'), 'TypeMismatch', 'Expected Int')
//
//	failMsg(|| => 'abc'.bogus(), 'NoSuchField', 'Field 'bogus' not found')
}

fn testList() {
    let funcs = [
        fn () {
            let a = []
            let b = [true]
            let c = [false,22]
            let d = b[0]
            b[0] = 33
            let e = c[1]++
        }
//        },
//        fn () {
//	assert(struct{a: 1} has 'a' == true)
//	assert(struct{a: 1} has 'b' == false)
//            let a = []
//            a.add(1)
//            assert(a == [1])
//            a.add(2).add([3])
//            assert(a == [1,2,[3]])
//            let b = []
//            b.add(4)
//            assert(b == [4])
//            assert(a.add == a.add)
//            assert(b.add == b.add)
//            assert(a.add != b.add)
//            assert(b.add != a.add)
//        },
//        fn () {
//            let a = []
//            a.addAll([1,2]).addAll('bc')
//            assert(a == [1,2,'b','c'])
//            let b = []
//            b.addAll(range(0,3))
//            b.addAll(dict { (true,false): 1, 'y': 2 })
//            assert(b == [ 0, 1, 2, ((true,false), 1), ('y', 2)])
//            assert(a.addAll == a.addAll)
//            assert(b.addAll == b.addAll)
//            assert(a.addAll != b.addAll)
//            assert(b.addAll != a.addAll)
//            assert(a.add != a.addAll)
//        },
//        fn () {
//            let a = []
//            assert(a.isEmpty())
//            a.add(1)
//            assert(!a.isEmpty())
//            a.clear()
//            assert(a.isEmpty())
//        },
//        fn () {
//            let a = []
//            assert(!a.contains('x'))
//            assert(a.indexOf('x') == -1)
//            a = ['z', 'x']
//            assert(a.contains('x'))
//            assert(a.indexOf('x') == 1)
//        },
//        fn () {
//            let a = []
//            assert(a.join() == '')
//            assert(a.join(',') == '')
//            a.add(1)
//            assert(a.join() == '1')
//            assert(a.join(',') == '1')
//            a.add(2)
//            assert(a.join() == '12')
//            assert(a.join(',') == '1,2')
//            a.add('abc')
//            assert(a.join() == '12abc')
//            assert(a.join(',') == '1,2,abc')
//        },
//        fn () {
//            let ls = [true, 0, 'abc']
//            let types = ls.map(type)
//            assert(types == ['Bool', 'Int', 'Str'])
//        },
//        fn () {
//            let ls = [1, 2, 3, 4, 5]
//            let squares = ls.map(|x| => x * x)
//            let addedUp = ls.reduce(0, |acc, x| => acc + x)
//            let even = ls.filter(|x| => (x % 2 == 0))
//
//            assert(squares == [1, 4, 9, 16, 25])
//            assert(addedUp == 15)
//            assert(even == [2, 4])
//
//            ls.remove(2)
//            assert(ls == [1, 2, 4, 5])
//        },
//        fn () {
//            let ls = [3, 4, 5]
//            assert(ls[0] == 3)
//            assert(ls[2] == 5)
//            assert(ls[0:3] == [3, 4, 5])
//            assert(ls[2:3] == [5])
//            let a = [1, 2, 3]
//            let n = 0
//            let b = a.map(fn(x) { n += x; x*x; })
//            assert(b == [1, 4, 9] && n == 6)
//
//            fail(|| => [].remove('a'), 'TypeMismatch')
//        }
    ]
    for f in funcs { f(); }
}

//fn testFreeze() {
//
//	fail(|| => freeze(null), 'NullValue')
//	fail(|| => frozen(null), 'NullValue')
//
//    assert(frozen(true))
//    assert(frozen('a'))
//    assert(frozen(1))
//    assert(frozen(1.0))
//    assert(frozen(range(1,2)))
//    assert(frozen(chan()))
//    assert(frozen(fn(){}))
//    assert(frozen((1,2)))
//
//    freeze(true)
//    freeze('a')
//    freeze(1)
//    freeze(1.0)
//    freeze(range(1,2))
//    freeze(chan())
//    freeze(fn(){})
//    freeze((1,2))
//
//    let ls = [1,2,3]
//    assert(!frozen(ls))
//
//    ls.clear()
//    ls.add('a')
//    ls.addAll(['b', 'c'])
//    ls.remove(1)
//    ls[1] = 'z'
//
//    assert(ls == ['a', 'z'])
//
//    freeze(ls)
//    assert(frozen(ls))
//    assert(ls == ['a', 'z']);
//
//    fail(|| => ls.clear(), 'ImmutableValue')
//    fail(|| => ls.add('a'), 'ImmutableValue')
//    fail(|| => ls.addAll(['b', 'c']), 'ImmutableValue')
//    fail(|| => ls.remove(1), 'ImmutableValue')
//    fail(|| => ls[1] = 'z', 'ImmutableValue')
//
//    let d = dict {'x': 1, 'y': 2}
//    assert(!frozen(d))
//
//    d.clear()
//    d.addAll([('a', 1), ('b', 2), ('c', 3)])
//    d.remove('c')
//    d['a'] = 0
//    assert(d == dict {'a': 0, 'b': 2})
//
//    freeze(d)
//    assert(frozen(d))
//    assert(d == dict {'a': 0, 'b': 2})
//
//    fail(|| => d.clear(), 'ImmutableValue')
//    fail(|| => d.addAll([('a', 1), ('b', 2), ('c', 3)]), 'ImmutableValue')
//    fail(|| => d.remove('c'), 'ImmutableValue')
//    fail(|| => d['a'] = 0, 'ImmutableValue')
//
//    let s = set {'x', 'y'}
//    assert(!frozen(s))
//
//    s.clear()
//    s.addAll('a')
//    s.addAll(['a', 'b', 'c'])
//    s.remove('c')
//    assert(s == set {'a', 'b'})
//
//    freeze(s)
//    assert(frozen(s))
//    assert(s == set {'a', 'b'})
//
//    fail(|| => s.clear(), 'ImmutableValue')
//    fail(|| => s.addAll('a'), 'ImmutableValue')
//    fail(|| => s.addAll(['a', 'b', 'c']), 'ImmutableValue')
//    fail(|| => s.remove('c'), 'ImmutableValue')
//
//    let st = struct {x: 1, y: 2}
//    st.y = 3
//
//    freeze(st)
//    assert(frozen(st))
//    assert(st == struct {x: 1, y: 3})
//
//    fail(|| => st.y = 3, 'ImmutableValue')
//
//    assert(!frozen(merge(struct {}, struct{})))
//    assert(frozen(merge(st, struct{})))
//    assert(frozen(merge(struct {}, st)))
//}
//
//fn testDict() {
//
//    let funcs = [
//        fn () {
//            let d = dict {'x': 1, 'y': 2};
//            d['x'] = 0;
//            assert(d == dict {'y': 2, 'x': 0});
//        },
//        fn () {
//            let a = dict { 'x': 1, 'y': 2 };
//            let b = a['x'];
//            let c = a['z'];
//            a['x'] = -1;
//            let d = a['x'];
//            assert([1, null, -1] == [b, c, d])
//        },
//        fn () {
//            let a = dict {};
//            a.addAll([(1,2)]).addAll([(3,4)]);
//            assert(a == dict {1:2,3:4});
//            let b = dict {};
//            assert(a.addAll == a.addAll);
//            assert(b.addAll == b.addAll);
//            assert(a.addAll != b.addAll);
//            assert(b.addAll != a.addAll);
//            assert(a.clear != a.addAll);
//        },
//        fn () {
//            let a = dict{}
//            failMsg(|| => a.addAll(false), 'TypeMismatch', 'Expected Iterable Type')
//            failMsg(|| => a.addAll([false]), 'TypeMismatch', 'Expected Tuple')
//            failMsg(|| => a.addAll([(1,2,3)]), 'TupleLength', 'Expected Tuple of length 2, got 3')
//            failMsg(|| => a[[1,2]], 'TypeMismatch', 'Expected Hashable Type')
//            failMsg(|| => a[[1,2]] = 3, 'TypeMismatch', 'Expected Hashable Type')
//            failMsg(|| => a.containsKey([1,2]), 'TypeMismatch', 'Expected Hashable Type')
//        },
//        fn () {
//            let a = dict {};
//            assert(a.isEmpty());
//            a[1] = 2;
//            assert(!a.isEmpty());
//            a.clear();
//            assert(a.isEmpty());
//        },
//        fn () {
//            let a = dict {'z': 3};
//            assert(a.containsKey('z'));
//            assert(!a.containsKey('x'));
//        },
//        fn () {
//            let d = dict {'a': 1, 'b': 2};
//            assert(!d.remove('z'));
//            assert(d.remove('a'));
//            assert(d == dict {'b': 2});
//            assert(d.remove('b'));
//            assert(d == dict {});
//            assert(len(d) == 0);
//        },
//        fn () {
//            let d = dict {'a': 1, 'b': 2};
//            assert(!d.remove('z'));
//            assert(d.remove('a'));
//            assert(d == dict {'b': 2});
//            assert(d.remove('b'));
//            assert(d == dict {});
//            assert(len(d) == 0);
//        },
//        fn () {
//            fail(|| => dict {null: 'b'}, 'NullValue')
//            failMsg(|| => dict {[]: 'b'}, 'TypeMismatch', 'Expected Hashable Type')
//        }
//    ]
//    for f in funcs { f(); }
//}

fn testSet() {

    assert(set {} == set{})
    assert(set {'a'} == set{'a'})
    assert(set {'a', 'b'} == set{'a', 'b'})
    assert(set {'a', 'b', 'c'} == set{'a', 'b', 'c'})

    assert(set {'a', 'b', 'c'} != set{'a', 'b', 'd'})
    assert(set {'a', 'b', 'c'} != set{'a', 'b'})
    assert(set {'a', 'b', 'c'} != set{'a'})
    assert(set {'a', 'b', 'c'} != set{})

//	code = `
//try {
//    let s = set {'a', 'b', null}
//    assert(false)
//} catch e {
//    assert(e.kind == "NullValue")
//}
//
//try {
//    let s = set {'a', 'b', []}
//    assert(false)
//} catch e {
//    assert(e.kind == "TypeMismatch")
//    assert(e.msg == "Expected Hashable Type")
//}
//
//    let funcs = [
//        fn () {
//            let a = set {};
//            a.add(1);
//            assert(a == set {1});
//            a.add(2).add(3).add(2);
//            assert(a == set {1,2,3});
//            assert(set {3,1,2} == set {1,2,3});
//            assert(set {1,2} != set {1,2,3});
//            let b = set { 4 };
//            b.add(4);
//            assert(b == set { 4 });
//            assert(a.add == a.add);
//            assert(b.add == b.add);
//            assert(a.add != b.add);
//            assert(b.add != a.add);
//        },
//        fn () {
//            let a = set {};
//            a.addAll([1,2]).addAll('bc');
//            assert(a == set {1,2,'b','c'});
//            let b = set {};
//            b.addAll(range(0,3));
//            assert(b == set { 0, 1, 2 });
//            assert(a.addAll == a.addAll);
//            assert(b.addAll == b.addAll);
//            assert(a.addAll != b.addAll);
//            assert(b.addAll != a.addAll);
//            assert(a.add != a.addAll);
//        },
//        fn () {
//            failMsg(fn() { let a = set{}; a.addAll(false); },   'TypeMismatch', 'Expected Iterable Type')
//            failMsg(fn() { let a = set{}; a.add(3,4); },        'ArityMismatch', 'Expected 1 params, got 2')
//            failMsg(fn() { let a = set{}; a.add([1,2]); },      'TypeMismatch', 'Expected Hashable Type')
//            failMsg(fn() { let a = set{}; a.contains([1,2]); }, 'TypeMismatch', 'Expected Hashable Type')
//        },
//        fn () {
//            let a = set{};
//            assert(a.isEmpty());
//            a.add(1);
//            assert(!a.isEmpty());
//            a.clear();
//            assert(a.isEmpty());
//        },
//        fn () {
//            let a = set{};
//            assert(!a.contains('x'));
//            a = set {'z', 'x'};
//        },
//        fn () {
//            let s = set {'a', 'b', 'c'};
//            assert(!s.remove('z'));
//            assert(s.remove('a'));
//            assert(s == set {'c', 'b'});
//            assert(s.remove('b'));
//            assert(s == set {'c'});
//            assert(len(s) == 1);
//            assert(s.remove('c'));
//            assert(s == set {});
//            assert(len(s) == 0);
//        }
//    ]
//    for f in funcs { f(); }
}

//fn testTuple() {
//
//    let a = (4,5)
//    let b = a[0]
//    let c = a[1]
//    assert(b == 4)
//    assert(c == 5)
//    assert(len(a) == 2)
//
//    failMsg(|| => a[2], 'IndexOutOfBounds', '2')
//}
//
//fn testTypes() {
//    let values = [
//        true, '', 0, 0.0, fn(){}, 
//        [], range(0,1), (0,1), dict{}, set{}, 
//        struct{}, chan()]
//
//    assert(
//        [ 'Bool', 'Str', 'Int', 'Float', 'Func', 'List', 'Range', 
//          'Tuple', 'Dict', 'Set', 'Struct', 'Chan'] == 
//        values.map(type))
//}
//
//fn testGo() {
//    fn sum(a, c) {
//        let total = 0
//        for v in a {
//            total += v
//        }
//        c.send(total)
//    }
//
//    let a = [7, 2, 8, -9, 4, 0]
//    let n = len(a) / 2
//    let c = chan()
//
//    go sum(a[:n], c)
//    go sum(a[n:], c)
//    let x = c.recv()
//    let y = c.recv()
//    assert([x, y] == [-5, 17])
//
//    let ch = chan(2)
//    ch.send(1)
//    ch.send(2)
//    assert([ch.recv(), ch.recv()] == [1, 2])
//}
//
//fn testFields() {
//
//    let s = struct {a: 1, b: 2}
//    assert(fields(s) == set {'a', 'b'})
//    assert(getval(s, 'a') == 1)
//    assert(setval(s, 'a', 3) == 3)
//    s.a++ // TODO fix compiler
//
//    failMsg(|| => fields(0),       'TypeMismatch' , 'Expected Struct')
//    failMsg(|| => fields(0, 1),    'ArityMismatch', 'Expected 1 params, got 2')
//    failMsg(|| => getval(0, 1),    'TypeMismatch' , 'Expected Struct')
//    failMsg(|| => getval(s, 1),    'TypeMismatch' , 'Expected Str')
//    failMsg(|| => getval(0),       'ArityMismatch', 'Expected 2 params, got 1')
//    failMsg(|| => setval(0, 1, 2), 'TypeMismatch' , 'Expected Struct')
//    failMsg(|| => setval(s, 1, 2), 'TypeMismatch' , 'Expected Str')
//    failMsg(|| => setval(0),       'ArityMismatch', 'Expected 3 params, got 1')
//    failMsg(|| => setval(0, 1),    'ArityMismatch', 'Expected 3 params, got 2')
//}
//
//fn testArity() {
//
////    assert(arity(type) == struct { min: 1, max: 1 });
////    assert(arity(print) == struct { min: 0, max: -1 })
////    assert(arity(|x,y| => x + y) == struct { min: 2, max: 2 })
//
//    failMsg(|| => arity(0), 'TypeMismatch', 'Expected Func')
//}

fn testRange() {

    let rng = range(0, 10)
    assert(set { 'to', 'count', 'step', 'from' } == fields(rng))
    for f in fields(rng) {
        assert(hasField(rng, f))
    }
    assert(rng.to == getField(rng, 'to'))
    assert(rng.count == getField(rng, 'count'))
    assert(rng.step == getField(rng, 'step'))
    assert(rng.from == getField(rng, 'from'))

    assert(!hasField(rng, 'bogus'))
    fail(|| => getField(rng, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => setField(rng, 'bogus', null), "TypeMismatch: Expected Struct")

    //-----------------------------------------

    fn listify(r) {
        let ls = []
        for n in r {
            ls.add(n)
        }
        return ls
    }

    let a = range(0, 5)
    let b = range(0, 5, 2)
    let c = range(2, 14, 3)
    let d = range(-1, -8, -3)
    let e = range(2, 2)
    let f = range(-1, -1, -1)
    assert(listify(a) == [ 0, 1, 2, 3, 4 ])
    assert(listify(b) == [ 0, 2, 4 ])
    assert(listify(c) == [ 2, 5, 8, 11 ])
    assert(listify(d) == [ -1, -4, -7 ])
    assert(listify(e) == [])
    assert(listify(f) == [])
    assert([a.from(), a.to(), a.step(), a.count()] == [0, 5, 1, 5])
    assert([b.from(), b.to(), b.step(), b.count()] == [0, 5, 2, 3])
    assert([c.from(), c.to(), c.step(), c.count()] == [2, 14, 3, 4])
    assert([d.from(), d.to(), d.step(), d.count()] == [-1, -8, -3, 3])
    assert([e.from(), e.to(), e.step(), e.count()] == [2, 2, 1, 0])

    let i = 0
    while i < a.count() {
        assert(a[i] == i)
        i++
    } 
}

fn testSlice() {
    let ls = [3,4,5];
    assert(ls[0:1] == [3]);
    assert(ls[1:3] == [4,5]);
    assert(ls[-2:-1] == [4]);
    assert(ls[-5:-4] == []);
    assert(ls[3:4] == []);
    let s = '345';
    assert(s[0:1] == '3');
    assert(s[1:3] == '45');
    assert(s[-2:-1] == '4');
    assert(s[-5:-4] == '');
    assert(s[3:4] == '');
}

fn testStruct() {

    let funcs = [
        fn () {
            assert(struct{} == struct{})
            assert(struct{a:1} == struct{a:1})
            assert(struct{a:1,b:2} == struct{a:1,b:2})
            assert(struct{a:1} != struct{a:1,b:2})
            assert(struct{a:1,b:2} != struct{b:2})
            assert(struct{a:1,b:2} != struct{a:3,b:2})
        },
        fn () {
            let w = struct {}
            let x = struct { a: 0 }
            let y = struct { a: 1, b: 2 }
            let z = struct { a: 3, b: 4, c: struct { d: 5 } }

            assert([0] == [x.a])
            assert([1, 2] == [y.a, y.b])
            assert([3, 4, 5] == [z.a, z.b, z.c.d])

            for s in [w, x, y, z] {
                fail(|| => s.bogus, "NoSuchField: Field 'bogus' not found")
            }
        },
        fn () {
            let x = struct { a: 5 }
            let y = x.a
            x.a = 6
            assert([5, 6] == [y, x.a])
        },
        fn () {
            let a = struct {
                x: 8,
                y: 5,
                plus:  fn() { return this.x + this.y; },
                minus: fn() { return this.x - this.y; }
            }
            let b = a.plus()
            let c = a.minus()
            assert([13, 3] == [b, c])
        },
        fn () {
            let a = null
            a = struct { x: 8 }.x = 5
            assert(5 == a)
        },
        fn () {
            let s = struct { 
                a: prop { || => 1 } 
            }
            assert(1 == s.a)
            fail(|| => s.a = 2, "ReadonlyField: Field 'a' is readonly")
        },
        fn () {
            let x = 2
            let s = struct { 
                a: prop { || => 1 } ,
                b: prop { || => x, |v| => x = v },
                c: || => this.a + this.b
            }
            fail(|| => s.a = 2, "ReadonlyField: Field 'a' is readonly")

            assert([s.a, s.b, x, s.c()] == [1, 2, 2, 3])

            s.b = 3
            assert([s.a, s.b, x, s.c()] == [1, 3, 3, 4])

            x = 4
            assert([s.a, s.b, x, s.c()] == [1, 4, 4, 5])
        }
    ]
    for f in funcs { f(); }
}

//fn testMerge() {
//
//	failMsg(|| => merge(), 'ArityMismatch', 'Expected at least 2 params, got 0')
//	failMsg(|| => merge(true), 'ArityMismatch', 'Expected at least 2 params, got 1')
//	failMsg(|| => merge(struct{}, false), 'TypeMismatch', 'Expected Struct')
//	failMsg(|| => merge(struct{}, struct{}, struct{}, false), 'TypeMismatch', 'Expected Struct')
//
//    let a = struct { x: 1, y: 2}
//    let b = merge(struct { y: 3, z: 4}, a)
//    assert(b.x == 1)
//    assert(b.y == 3)
//    assert(b.z == 4)
//    a.x = 5
//    a.y = 6
//    assert(b.x == 5)
//    assert(b.y == 3)
//    assert(b.z == 4)
//    let c = merge(struct { w: 10}, b)
//    assert(c.w == 10)
//    assert(c.x == 5)
//    assert(c.y == 3)
//    assert(c.z == 4)
//    a.x = 7
//    b.z = 11
//    assert(c.w == 10)
//    assert(c.x == 7)
//    assert(c.y == 3)
//    assert(c.z == 11)
//
//    let z = merge(struct { a: 1}, struct { b: 2}, struct { c: 3}, struct { d: 4})
//    assert(struct { a: 1, b: 2, c: 3, d: 4} == z)
//}

fn testIterator() {
    
    // list
    fail(|| => iter([]).get(), 'NoSuchElement')
    let count = 0
    let itr = iter([1, 2, 3])
    fail(|| => itr.get(), 'NoSuchElement')
    while itr.next() {
        count += itr.get()
    }
    assert(6 == count)
    fail(|| => itr.get(), 'NoSuchElement')

    // range
    fail(|| => iter(range(0, 0)).get(), 'NoSuchElement')
    count = 0
    itr = iter(range(1, 5))
    fail(|| => itr.get(), 'NoSuchElement')
    while itr.next() {
        count += itr.get()
    }
    assert(10 == count)
    fail(|| => itr.get(), 'NoSuchElement')

//    // dict
//    fail(|| => dict{}.iter().get(), 'NoSuchElement')
//    count = 0
//    itr = dict{'a': 1, 'b': 2}.iter()
//    fail(|| => itr.get(), 'NoSuchElement')
//    while itr.next() {
//        let e = itr.get()
//        // let (k, v) = itr.get() TODO this would be cool
//        count += e[1]
//    }
//    assert(3 == count)
//    fail(|| => itr.get(), 'NoSuchElement')
//
//    // set
//    fail(|| => set{}.iter().get(), 'NoSuchElement')
//    count = 0
//    itr = set{3, 4, 1, 4}.iter()
//    fail(|| => itr.get(), 'NoSuchElement')
//    while itr.next() {
//        count += itr.get()
//    }
//    assert(8 == count)
//    fail(|| => itr.get(), 'NoSuchElement')
//
//    // str
//    fail(|| => ''.iter().get(), 'NoSuchElement')
//    count = ''
//    itr = 'abcde'.iter()
//    fail(|| => itr.get(), 'NoSuchElement')
//    while itr.next() {
//        count = itr.get() + count
//    }
//    assert('edcba' == count)
//    fail(|| => itr.get(), 'NoSuchElement')
}

fn testInvokeField() {
    let s = 'abc'
    let c = s.contains
    let x = c('b')
    let y = s.contains('z')

    let ls = [1]
    let p = iter(ls).next()

    assert([true, false, true] == [x, y, p])
}

fn main(args) {

//---------------------------------------------
//code := "null.bogus;"
//fail(t, code,
//	g.NullValueError(),
//	[]string{"    at foo.glm:1"})

//err := g.NoSuchFieldError("bogus")

//failErr(t, "true.bogus;", err)
//failErr(t, "'a'.bogus;", err)
//failErr(t, "(0).bogus;", err)
//failErr(t, "(0.123).bogus;", err)

//failErr(t, "(1,2).bogus;", err)
//failErr(t, "range(1,2).bogus;", err)
//failErr(t, "[1,2].bogus;", err)
//failErr(t, "dict {'a':1}.bogus;", err)
//failErr(t, "struct {a:1}.bogus;", err)

//failErr(t, "(fn() {}).bogus;", err)
//---------------------------------------------
//	code := `
//try {
//    [].join = 456;
//} catch e {
//    assert(e.kind == 'TypeMismatch');
//    assert(e.msg == "Expected Struct");
//}
//---------------------------------------------
//
//	code := `
//assert(
//    [type(true), type(""), type(0), type(0.0)] ==
//    ["Bool", "Str", "Int", "Float"]);
//assert(
//    [type(fn(){}), type([]), type(range(0,1)), type((0,1))] ==
//    ["Func", "List", "Range", "Tuple"]);
//assert(
//    [type(dict{}), type(set{}), type(struct{}), type(chan())] ==
//    ["Dict", "Set", "Struct", "Chan"]);
//`
//	mod := testCompile(t, code)
//	interpret([]*g.Module{mod})
//}
//---------------------------------------------

    assert(42 == zork.quux)

    assert(assert == assert);
    assert(print == print);
    assert(println == println);
    assert(assert != print);
    assert(assert != println);
    assert(print != println);

    testExpressions()
    testAssignment()
    testFlowControl()
    testTry()

    testFunc()
    testCapture()
    testNamedFunc()
    testLambda()

    testNull()
    testStr()
    testList()
//    testFreeze()
//    testDict()
    testSet()
//    testTuple()
//    testTypes()
//    testGo()
//    testFields()
//    testArity()
    testRange()
    testStruct()
//    testMerge()
    testSlice()

//    testIterator()
    testInvokeField()
}


