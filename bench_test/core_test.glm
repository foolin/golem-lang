// Copyright 2018 The Golem Language Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

//import zork

fn fail(func, err) {
    try {
        func()
        assert(false)
    } catch e {
        assert(err == e.error)

        //println("BenchTestError: " + err + " != " + e.error)

        ////println('==============================================')
        //if err != e.error {
        //    //throw "BenchTestError: " + err + " != " + e.error
        //    println("BenchTestError: " + err + " != " + e.error)
        //    assert(false)
        //    //assert(err == e.error)
        //}
    }
}

fn testExpressions() {

	assert((2 + 3) * -4 / 10 == -2)
	assert((2*2*2*2 + 2*3*(8 - 1) + 2) / (17 - 2*2*2 - -1) == 6)

	assert(true + 'a' == 'truea')
	assert('a' + true == 'atrue')
	assert('a' + null == 'anull')
	assert(null + 'a' == 'nulla')

	fail(|| => true + null, 'TypeMismatch: Expected Number Type')
	fail(|| => 1 + null, 'TypeMismatch: Expected Number Type')
	fail(|| => null + 1, 'TypeMismatch: Expected Number Type')

	assert((true == 'a') == false)
	assert((3 * 7 + 4 == 5 * 5) == true)
	assert((1 != 1) == false)
	assert((1 != 2) == true)

	assert(!false == true)
	assert(!true == false)
	fail(|| => !null, 'TypeMismatch: Expected Bool')
	fail(|| => !'a', 'TypeMismatch: Expected Bool')
	fail(|| => !1, 'TypeMismatch: Expected Bool')
	fail(|| => !1.0, 'TypeMismatch: Expected Bool')

	assert(1 < 2 == true)
	assert(1 <= 2 == true)
	assert(1 > 2 == false)
	assert(1 >= 2 == false)

	assert(2 < 2 == false)
	assert(2 <= 2 == true)
	assert(2 > 2 == false)
	assert(2 >= 2 == true)

	assert(1 <=> 2 == -1)
	assert(2 <=> 2 == 0)
	assert(2 <=> 1 == 1)

	assert((true  && true) == true)
	assert((true  && false) == false)
	assert((false && true) == false)
	assert((false && 12) == false)
	fail(|| => 12 && false, 'TypeMismatch: Expected Bool')

	assert(true  || (true == true))
	assert(true  || (false == true))
	assert(false || (true == true))
	assert(false || (false == false))
	assert(true  || (12 == true))
	fail(|| => 12  || true, 'TypeMismatch: Expected Bool')

	assert(~0 == -1)
	assert(8 % 2 == 0)
	assert(8 & 2 == 0)
	assert(8 | 2 == 10)
	assert(8 ^ 2 == 10)
	assert(8 << 2 == 32)
	assert(8 >> 2 == 2)

	assert([true][0] == true)
	assert('abc'[1] == 'b')
	assert('abc'[-1] == 'c')
	fail(|| => [true][2], 'IndexOutOfBounds: 2')

	assert('abc'[1:] == 'bc')
	assert('abc'[:1] == 'a')
	assert('abcd'[1:3] == 'bc')
	assert('abcd'[1:1] == '')

	assert([6,7,8][1:] == [7,8])
	assert([6,7,8][:1] == [6])
	assert([6,7,8,9][1:3] == [7,8])
	assert([6,7,8,9][1:1] == [])

}

fn testAssignment() {
    let funcs = [
        fn () {
            let a = 1
            const b = 2
            a = a + b
            assert([3, 2] == [a, b])
        },
        fn () {
            let a = 1
            a = a + 41
            const b = a / 6
            let c = b + 3
            c = (c + a)/13
            assert([42, 7, 4] == [a, b, c])
        },
        fn () {
            let a = 1
            let b = a += 3
            let c = ~0
            c -= -2
            c <<= 4
            b *= 2
            assert([4, 8, 16] == [a, b, c])
        },
        fn () {
            let a = 1
            let b = 2
            a = b = 11
            b = a %= 4
            assert([3, 3] == [a, b])
        }
    ]
    for f in funcs { f(); }
}

fn testFlowControl() {
    let funcs = [
        fn () {
            let a = 1; if (true) { a = 2; }
            assert(a == 2)
        },
        fn () {
            let a = 1; if (false) { a = 2; }
            assert(a == 1)
        },
        fn () {
            let a = 1; if (1 == 1) { a = 2; } else { a = 3; }; let b = 4;
            assert(a == 2 && b == 4)
        },
        fn () {
            let a = 1; if (1 == 2) { a = 2; } else { a = 3; }; const b = 4;
            assert(a == 3 && b == 4)
        },
        fn () {
            let a = 1
            while (a < 3) {
                a = a + 1
            }
            assert(a == 3)
        },
        fn () {
            let a = 1
            while (a < 11) {
                if (a == 4) { a = a + 2; break; }
                a = a + 1
            }
            assert(a == 6)
        },
        fn () {
            let a = 1
            let b = 0
            while (a < 11) {
                a = a + 1
                if (a > 5) { continue; }
                b = b + 1
            }
            assert(a == 11 && b == 4)
        }
    ]
    for f in funcs { f(); }
}

//--------------------------------------------------------------
//--------------------------------------------------------------
//--------------------------------------------------------------

//fn testFunc() {
//
//    let a = fn(x) { x; }
//    let b = a(1)
//    assert(b == 1)
//
//    //------------------------------------------
//
//    a = fn() { }
//    b = fn(x) { x; }
//    let c = fn(x, y) { let z = 4; x * y * z; }
//    let d = a()
//    let e = b(1)
//    let f = c(b(2), 3)
//    assert([null, 1, 24] == [d, e, f])
//
//    //------------------------------------------
//
//    let fibonacciGenerator = fn() {
//        let x = 1
//        let y = 1
//        return fn() {
//            let z = x
//            x = y
//            y = x + z
//            return z
//        }
//    }
//    let fg = fibonacciGenerator()
//    let list = []
//    for i in range(0, 10) {
//        list.add(fg())
//    }
//    assert([1, 1, 2, 3, 5, 8, 13, 21, 34, 55] == list)
//
//    //------------------------------------------
//
//    let foo = fn(n) {
//        let bar = fn(x) {
//            return x * (x - 1)
//        }
//        return bar(n) + bar(n-1)
//    }
//    assert(32 == foo(5))
//
//    //------------------------------------------
//
//	fail(|| => 1/0, 'DivideByZero')
//}
//
//fn testCapture() {
//
//    const accumGen = fn(n) {
//        return fn(i) {
//            n = n + i
//            return n
//        }
//    }
//    const a = accumGen(3)
//    const x = a(2)
//    const y = a(7)
//    assert([5, 12] == [x, y])
//
//    //---------------------
//
//    let z = 2
//    const acc2 = fn(n) {
//        return fn(i) {
//            n = n + i
//            n = n + z
//            return n
//        }
//    }
//    const b = acc2(3)
//    let i = b(2)
//    z = 0
//    let j = b(1)
//    assert([0, 7, 8] == [z, i, j])
//
//    const m = 123
//    const n = 456
//
//    fn foo() {
//        assert(n == 456)
//        assert(m == 123)
//    }
//    foo()
//
//    //---------------------
//
//    const cap = 1
//    let f1 = || => cap
//    let f2 = || => cap
//    assert([1, 1] == [f1(), f2()])
//}
//
//fn testNamedFunc() {
//    fn a() {
//        return b()
//    }
//    fn b() {
//        return 42
//    }
//    assert(a() == 42)
//}
//
//fn testLambda() {
//    let z = 5
//    let a = || => 3
//    let b = |x| => x * x
//    let c = |x, y| => (x + y)*z
//    assert(a() == 3)
//    assert(b(2) == 4)
//    assert(c(1, 2) == 15)
//}
//
//fn testStr() {
//
//	assert(struct{a: 1} has 'a' == true)
//	assert(struct{a: 1} has 'b' == false)
//    assert('abc'.contains('b'))
//    assert(!'abc'.contains('z'))
//    assert('abc'.index('b') == 1)
//    assert('abc'.index('z') == -1)
//    assert('abc'.startsWith('a'))
//    assert(!'abc'.startsWith('z'))
//    assert('abc'.endsWith('c'))
//    assert(!'abc'.endsWith('z'))
//    assert('aaa'.replace('a', 'z') == 'zzz')
//    assert('aaa'.replace('a', 'z', 2) == 'zza')
//    assert('aaa'.replace('a', 'z', 0) == 'aaa')
//    assert('aaa'.replace('a', 'z', -1) == 'zzz')
//    assert('a,b,c'.split(',') == ['a','b','c'])
//
//    assert('abcabc'.lastIndex('ab') == 3)
//    assert('abc'.lastIndex('z') == -1)
//
//    fn ext(s) {
//        let n = s.lastIndex('.')
//        return n == -1 ? '' : s[n:]
//    }
//    assert(ext('foo') == '')
//    assert(ext('foo.txt') == '.txt')
//
//	failMsg(|| => 'abc'.contains(), 'ArityMismatch', 'Expected 1 params, got 0')
//	failMsg(|| => 'abc'.contains(1), 'TypeMismatch', 'Expected Str')
//
//	failMsg(|| => 'abc'.index(), 'ArityMismatch', 'Expected 1 params, got 0')
//	failMsg(|| => 'abc'.index(1), 'TypeMismatch', 'Expected Str')
//	failMsg(|| => 'abc'.lastIndex(), 'ArityMismatch', 'Expected 1 params, got 0')
//	failMsg(|| => 'abc'.lastIndex(1), 'TypeMismatch', 'Expected Str')
//
//	failMsg(|| => 'abc'.startsWith(), 'ArityMismatch', 'Expected 1 params, got 0')
//	failMsg(|| => 'abc'.startsWith(1), 'TypeMismatch', 'Expected Str')
//
//	failMsg(|| => 'abc'.endsWith(), 'ArityMismatch', 'Expected 1 params, got 0')
//	failMsg(|| => 'abc'.endsWith(1), 'TypeMismatch', 'Expected Str')
//
//	failMsg(|| => 'abc'.replace(), 'ArityMismatch', 'Expected at least 2 params, got 0')
//	failMsg(|| => 'abc'.replace(1,2,3,4), 'ArityMismatch', 'Expected at most 3 params, got 4')
//	failMsg(|| => 'abc'.replace(0, 'a'), 'TypeMismatch', 'Expected Str')
//	failMsg(|| => 'abc'.replace('a', 0), 'TypeMismatch', 'Expected Str')
//	failMsg(|| => 'abc'.replace('a', 'b', 'c'), 'TypeMismatch', 'Expected Int')
//
//	failMsg(|| => 'abc'.bogus(), 'NoSuchField', 'Field 'bogus' not found')
//}

fn testList() {
    let funcs = [
        fn () {
            let a = []
            let b = [true]
            let c = [false,22]
            let d = b[0]
            b[0] = 33
            let e = c[1]++
        }
//        },
//        fn () {
//	assert(struct{a: 1} has 'a' == true)
//	assert(struct{a: 1} has 'b' == false)
//            let a = []
//            a.add(1)
//            assert(a == [1])
//            a.add(2).add([3])
//            assert(a == [1,2,[3]])
//            let b = []
//            b.add(4)
//            assert(b == [4])
//            assert(a.add == a.add)
//            assert(b.add == b.add)
//            assert(a.add != b.add)
//            assert(b.add != a.add)
//        },
//        fn () {
//            let a = []
//            a.addAll([1,2]).addAll('bc')
//            assert(a == [1,2,'b','c'])
//            let b = []
//            b.addAll(range(0,3))
//            b.addAll(dict { (true,false): 1, 'y': 2 })
//            assert(b == [ 0, 1, 2, ((true,false), 1), ('y', 2)])
//            assert(a.addAll == a.addAll)
//            assert(b.addAll == b.addAll)
//            assert(a.addAll != b.addAll)
//            assert(b.addAll != a.addAll)
//            assert(a.add != a.addAll)
//        },
//        fn () {
//            let a = []
//            assert(a.isEmpty())
//            a.add(1)
//            assert(!a.isEmpty())
//            a.clear()
//            assert(a.isEmpty())
//        },
//        fn () {
//            let a = []
//            assert(!a.contains('x'))
//            assert(a.indexOf('x') == -1)
//            a = ['z', 'x']
//            assert(a.contains('x'))
//            assert(a.indexOf('x') == 1)
//        },
//        fn () {
//            let a = []
//            assert(a.join() == '')
//            assert(a.join(',') == '')
//            a.add(1)
//            assert(a.join() == '1')
//            assert(a.join(',') == '1')
//            a.add(2)
//            assert(a.join() == '12')
//            assert(a.join(',') == '1,2')
//            a.add('abc')
//            assert(a.join() == '12abc')
//            assert(a.join(',') == '1,2,abc')
//        },
//        fn () {
//            let ls = [true, 0, 'abc']
//            let types = ls.map(type)
//            assert(types == ['Bool', 'Int', 'Str'])
//        },
//        fn () {
//            let ls = [1, 2, 3, 4, 5]
//            let squares = ls.map(|x| => x * x)
//            let addedUp = ls.reduce(0, |acc, x| => acc + x)
//            let even = ls.filter(|x| => (x % 2 == 0))
//
//            assert(squares == [1, 4, 9, 16, 25])
//            assert(addedUp == 15)
//            assert(even == [2, 4])
//
//            ls.remove(2)
//            assert(ls == [1, 2, 4, 5])
//        },
//        fn () {
//            let ls = [3, 4, 5]
//            assert(ls[0] == 3)
//            assert(ls[2] == 5)
//            assert(ls[0:3] == [3, 4, 5])
//            assert(ls[2:3] == [5])
//            let a = [1, 2, 3]
//            let n = 0
//            let b = a.map(fn(x) { n += x; x*x; })
//            assert(b == [1, 4, 9] && n == 6)
//
//            fail(|| => [].remove('a'), 'TypeMismatch')
//        }
    ]
    for f in funcs { f(); }
}

//fn testFreeze() {
//
//	fail(|| => freeze(null), 'NullValue')
//	fail(|| => frozen(null), 'NullValue')
//
//    assert(frozen(true))
//    assert(frozen('a'))
//    assert(frozen(1))
//    assert(frozen(1.0))
//    assert(frozen(range(1,2)))
//    assert(frozen(chan()))
//    assert(frozen(fn(){}))
//    assert(frozen((1,2)))
//
//    freeze(true)
//    freeze('a')
//    freeze(1)
//    freeze(1.0)
//    freeze(range(1,2))
//    freeze(chan())
//    freeze(fn(){})
//    freeze((1,2))
//
//    let ls = [1,2,3]
//    assert(!frozen(ls))
//
//    ls.clear()
//    ls.add('a')
//    ls.addAll(['b', 'c'])
//    ls.remove(1)
//    ls[1] = 'z'
//
//    assert(ls == ['a', 'z'])
//
//    freeze(ls)
//    assert(frozen(ls))
//    assert(ls == ['a', 'z']);
//
//    fail(|| => ls.clear(), 'ImmutableValue')
//    fail(|| => ls.add('a'), 'ImmutableValue')
//    fail(|| => ls.addAll(['b', 'c']), 'ImmutableValue')
//    fail(|| => ls.remove(1), 'ImmutableValue')
//    fail(|| => ls[1] = 'z', 'ImmutableValue')
//
//    let d = dict {'x': 1, 'y': 2}
//    assert(!frozen(d))
//
//    d.clear()
//    d.addAll([('a', 1), ('b', 2), ('c', 3)])
//    d.remove('c')
//    d['a'] = 0
//    assert(d == dict {'a': 0, 'b': 2})
//
//    freeze(d)
//    assert(frozen(d))
//    assert(d == dict {'a': 0, 'b': 2})
//
//    fail(|| => d.clear(), 'ImmutableValue')
//    fail(|| => d.addAll([('a', 1), ('b', 2), ('c', 3)]), 'ImmutableValue')
//    fail(|| => d.remove('c'), 'ImmutableValue')
//    fail(|| => d['a'] = 0, 'ImmutableValue')
//
//    let s = set {'x', 'y'}
//    assert(!frozen(s))
//
//    s.clear()
//    s.addAll('a')
//    s.addAll(['a', 'b', 'c'])
//    s.remove('c')
//    assert(s == set {'a', 'b'})
//
//    freeze(s)
//    assert(frozen(s))
//    assert(s == set {'a', 'b'})
//
//    fail(|| => s.clear(), 'ImmutableValue')
//    fail(|| => s.addAll('a'), 'ImmutableValue')
//    fail(|| => s.addAll(['a', 'b', 'c']), 'ImmutableValue')
//    fail(|| => s.remove('c'), 'ImmutableValue')
//
//    let st = struct {x: 1, y: 2}
//    st.y = 3
//
//    freeze(st)
//    assert(frozen(st))
//    assert(st == struct {x: 1, y: 3})
//
//    fail(|| => st.y = 3, 'ImmutableValue')
//
//    assert(!frozen(merge(struct {}, struct{})))
//    assert(frozen(merge(st, struct{})))
//    assert(frozen(merge(struct {}, st)))
//}
//
//fn testDict() {
//
//    let funcs = [
//        fn () {
//            let d = dict {'x': 1, 'y': 2};
//            d['x'] = 0;
//            assert(d == dict {'y': 2, 'x': 0});
//        },
//        fn () {
//            let a = dict { 'x': 1, 'y': 2 };
//            let b = a['x'];
//            let c = a['z'];
//            a['x'] = -1;
//            let d = a['x'];
//            assert([1, null, -1] == [b, c, d])
//        },
//        fn () {
//            let a = dict {};
//            a.addAll([(1,2)]).addAll([(3,4)]);
//            assert(a == dict {1:2,3:4});
//            let b = dict {};
//            assert(a.addAll == a.addAll);
//            assert(b.addAll == b.addAll);
//            assert(a.addAll != b.addAll);
//            assert(b.addAll != a.addAll);
//            assert(a.clear != a.addAll);
//        },
//        fn () {
//            let a = dict{}
//            failMsg(|| => a.addAll(false), 'TypeMismatch', 'Expected Iterable Type')
//            failMsg(|| => a.addAll([false]), 'TypeMismatch', 'Expected Tuple')
//            failMsg(|| => a.addAll([(1,2,3)]), 'TupleLength', 'Expected Tuple of length 2, got 3')
//            failMsg(|| => a[[1,2]], 'TypeMismatch', 'Expected Hashable Type')
//            failMsg(|| => a[[1,2]] = 3, 'TypeMismatch', 'Expected Hashable Type')
//            failMsg(|| => a.containsKey([1,2]), 'TypeMismatch', 'Expected Hashable Type')
//        },
//        fn () {
//            let a = dict {};
//            assert(a.isEmpty());
//            a[1] = 2;
//            assert(!a.isEmpty());
//            a.clear();
//            assert(a.isEmpty());
//        },
//        fn () {
//            let a = dict {'z': 3};
//            assert(a.containsKey('z'));
//            assert(!a.containsKey('x'));
//        },
//        fn () {
//            let d = dict {'a': 1, 'b': 2};
//            assert(!d.remove('z'));
//            assert(d.remove('a'));
//            assert(d == dict {'b': 2});
//            assert(d.remove('b'));
//            assert(d == dict {});
//            assert(len(d) == 0);
//        },
//        fn () {
//            let d = dict {'a': 1, 'b': 2};
//            assert(!d.remove('z'));
//            assert(d.remove('a'));
//            assert(d == dict {'b': 2});
//            assert(d.remove('b'));
//            assert(d == dict {});
//            assert(len(d) == 0);
//        },
//        fn () {
//            fail(|| => dict {null: 'b'}, 'NullValue')
//            failMsg(|| => dict {[]: 'b'}, 'TypeMismatch', 'Expected Hashable Type')
//        }
//    ]
//    for f in funcs { f(); }
//}
//
//fn testSet() {
//
//    let funcs = [
//        fn () {
//            let a = set {};
//            a.add(1);
//            assert(a == set {1});
//            a.add(2).add(3).add(2);
//            assert(a == set {1,2,3});
//            assert(set {3,1,2} == set {1,2,3});
//            assert(set {1,2} != set {1,2,3});
//            let b = set { 4 };
//            b.add(4);
//            assert(b == set { 4 });
//            assert(a.add == a.add);
//            assert(b.add == b.add);
//            assert(a.add != b.add);
//            assert(b.add != a.add);
//        },
//        fn () {
//            let a = set {};
//            a.addAll([1,2]).addAll('bc');
//            assert(a == set {1,2,'b','c'});
//            let b = set {};
//            b.addAll(range(0,3));
//            assert(b == set { 0, 1, 2 });
//            assert(a.addAll == a.addAll);
//            assert(b.addAll == b.addAll);
//            assert(a.addAll != b.addAll);
//            assert(b.addAll != a.addAll);
//            assert(a.add != a.addAll);
//        },
//        fn () {
//            failMsg(fn() { let a = set{}; a.addAll(false); },   'TypeMismatch', 'Expected Iterable Type')
//            failMsg(fn() { let a = set{}; a.add(3,4); },        'ArityMismatch', 'Expected 1 params, got 2')
//            failMsg(fn() { let a = set{}; a.add([1,2]); },      'TypeMismatch', 'Expected Hashable Type')
//            failMsg(fn() { let a = set{}; a.contains([1,2]); }, 'TypeMismatch', 'Expected Hashable Type')
//        },
//        fn () {
//            let a = set{};
//            assert(a.isEmpty());
//            a.add(1);
//            assert(!a.isEmpty());
//            a.clear();
//            assert(a.isEmpty());
//        },
//        fn () {
//            let a = set{};
//            assert(!a.contains('x'));
//            a = set {'z', 'x'};
//        },
//        fn () {
//            let s = set {'a', 'b', 'c'};
//            assert(!s.remove('z'));
//            assert(s.remove('a'));
//            assert(s == set {'c', 'b'});
//            assert(s.remove('b'));
//            assert(s == set {'c'});
//            assert(len(s) == 1);
//            assert(s.remove('c'));
//            assert(s == set {});
//            assert(len(s) == 0);
//        }
//    ]
//    for f in funcs { f(); }
//}
//
//fn testTuple() {
//
//    let a = (4,5)
//    let b = a[0]
//    let c = a[1]
//    assert(b == 4)
//    assert(c == 5)
//    assert(len(a) == 2)
//
//    failMsg(|| => a[2], 'IndexOutOfBounds', '2')
//}
//
//fn testTypes() {
//    let values = [
//        true, '', 0, 0.0, fn(){}, 
//        [], range(0,1), (0,1), dict{}, set{}, 
//        struct{}, chan()]
//
//    assert(
//        [ 'Bool', 'Str', 'Int', 'Float', 'Func', 'List', 'Range', 
//          'Tuple', 'Dict', 'Set', 'Struct', 'Chan'] == 
//        values.map(type))
//}
//
//fn testGo() {
//    fn sum(a, c) {
//        let total = 0
//        for v in a {
//            total += v
//        }
//        c.send(total)
//    }
//
//    let a = [7, 2, 8, -9, 4, 0]
//    let n = len(a) / 2
//    let c = chan()
//
//    go sum(a[:n], c)
//    go sum(a[n:], c)
//    let x = c.recv()
//    let y = c.recv()
//    assert([x, y] == [-5, 17])
//
//    let ch = chan(2)
//    ch.send(1)
//    ch.send(2)
//    assert([ch.recv(), ch.recv()] == [1, 2])
//}
//
//fn testFields() {
//
//    let s = struct {a: 1, b: 2}
//    assert(fields(s) == set {'a', 'b'})
//    assert(getval(s, 'a') == 1)
//    assert(setval(s, 'a', 3) == 3)
//    s.a++ // TODO fix compiler
//
//    failMsg(|| => fields(0),       'TypeMismatch' , 'Expected Struct')
//    failMsg(|| => fields(0, 1),    'ArityMismatch', 'Expected 1 params, got 2')
//    failMsg(|| => getval(0, 1),    'TypeMismatch' , 'Expected Struct')
//    failMsg(|| => getval(s, 1),    'TypeMismatch' , 'Expected Str')
//    failMsg(|| => getval(0),       'ArityMismatch', 'Expected 2 params, got 1')
//    failMsg(|| => setval(0, 1, 2), 'TypeMismatch' , 'Expected Struct')
//    failMsg(|| => setval(s, 1, 2), 'TypeMismatch' , 'Expected Str')
//    failMsg(|| => setval(0),       'ArityMismatch', 'Expected 3 params, got 1')
//    failMsg(|| => setval(0, 1),    'ArityMismatch', 'Expected 3 params, got 2')
//}
//
//fn testArity() {
//
////    assert(arity(type) == struct { min: 1, max: 1 });
////    assert(arity(print) == struct { min: 0, max: -1 })
////    assert(arity(|x,y| => x + y) == struct { min: 2, max: 2 })
//
//    failMsg(|| => arity(0), 'TypeMismatch', 'Expected Func')
//}
//
//fn testRange() {
//
//    fn listify(r) {
//        let ls = []
//        for n in r {
//            ls.add(n)
//        }
//        return ls
//    }
//    let a = range(0, 5)
//    let b = range(0, 5, 2)
//    let c = range(2, 14, 3)
//    let d = range(-1, -8, -3)
//    let e = range(2, 2)
//    let f = range(-1, -1, -1)
//    assert(listify(a) == [ 0, 1, 2, 3, 4 ])
//    assert(listify(b) == [ 0, 2, 4 ])
//    assert(listify(c) == [ 2, 5, 8, 11 ])
//    assert(listify(d) == [ -1, -4, -7 ])
//    assert(listify(e) == [])
//    assert(listify(f) == [])
//    assert([a.from(), a.to(), a.step(), a.count()] == [0, 5, 1, 5])
//    assert([b.from(), b.to(), b.step(), b.count()] == [0, 5, 2, 3])
//    assert([c.from(), c.to(), c.step(), c.count()] == [2, 14, 3, 4])
//    assert([d.from(), d.to(), d.step(), d.count()] == [-1, -8, -3, 3])
//    assert([e.from(), e.to(), e.step(), e.count()] == [2, 2, 1, 0])
//
//    let i = 0
//    while i < a.count() {
//        assert(a[i] == i)
//        i++
//    } 
//}
//
//fn testSlice() {
//    let ls = [3,4,5];
//    assert(ls[0:1] == [3]);
//    assert(ls[1:3] == [4,5]);
//    assert(ls[-2:-1] == [4]);
//    assert(ls[-5:-4] == []);
//    assert(ls[3:4] == []);
//    let s = '345';
//    assert(s[0:1] == '3');
//    assert(s[1:3] == '45');
//    assert(s[-2:-1] == '4');
//    assert(s[-5:-4] == '');
//    assert(s[3:4] == '');
//}
//
//fn testUnicodeEscape() {
//    let s = '\u{1f496}\u{2665}\u{24}'
//    assert(s[0] == 'ðŸ’–')
//    assert(s[1] == 'â™¥')
//    assert(s[2] == '$')
//}

fn testStruct() {

    let funcs = [
        fn () {
            assert(struct{} == struct{})
            assert(struct{a:1} == struct{a:1})
            assert(struct{a:1,b:2} == struct{a:1,b:2})
            assert(struct{a:1} != struct{a:1,b:2})
            assert(struct{a:1,b:2} != struct{b:2})
            assert(struct{a:1,b:2} != struct{a:3,b:2})
        },
        fn () {
            let w = struct {}
            let x = struct { a: 0 }
            let y = struct { a: 1, b: 2 }
            let z = struct { a: 3, b: 4, c: struct { d: 5 } }

            assert([0] == [x.a])
            assert([1, 2] == [y.a, y.b])
            assert([3, 4, 5] == [z.a, z.b, z.c.d])

            for s in [w, x, y, z] {
                fail(|| => s.bogus, "NoSuchField: Field 'bogus' not found")
            }
        },
        fn () {
            let x = struct { a: 5 }
            let y = x.a
            x.a = 6
            assert([5, 6] == [y, x.a])
        },
        fn () {
            let a = struct {
                x: 8,
                y: 5,
                plus:  fn() { return this.x + this.y; },
                minus: fn() { return this.x - this.y; }
            }
            let b = a.plus()
            let c = a.minus()
            assert([13, 3] == [b, c])
        },
        fn () {
            let a = null
            a = struct { x: 8 }.x = 5
            assert(5 == a)
        }
    ]
    for f in funcs { f(); }

//    let x = 2
//    let s = struct {
//
//        // 'a' is a readonly property with a getter function.
//        a: prop { || => 1 },
//
//        // 'b' is a property with getter and setters functions.
//        b: prop { || => x, |v| => x = v },
//
//        // 'a' and 'b' act like normal fields here.
//        c: || => this.a + this.b
//    }
//
//    try {
//        s.a = 42
//        assert(false) // we will never get here.
//    } catch e {
//        assert(e.kind == 'ReadonlyField')
//        assert(e.msg == 'Field 'a' is readonly')
//    }
//
//    assert([s.a, s.b, x, s.c()] == [1, 2, 2, 3])
//
//    s.b = 3
//    assert([s.a, s.b, x, s.c()] == [1, 3, 3, 4])
//
//    x = 4
//    assert([s.a, s.b, x, s.c()] == [1, 4, 4, 5])
}

//fn testMerge() {
//
//	failMsg(|| => merge(), 'ArityMismatch', 'Expected at least 2 params, got 0')
//	failMsg(|| => merge(true), 'ArityMismatch', 'Expected at least 2 params, got 1')
//	failMsg(|| => merge(struct{}, false), 'TypeMismatch', 'Expected Struct')
//	failMsg(|| => merge(struct{}, struct{}, struct{}, false), 'TypeMismatch', 'Expected Struct')
//
//    let a = struct { x: 1, y: 2}
//    let b = merge(struct { y: 3, z: 4}, a)
//    assert(b.x == 1)
//    assert(b.y == 3)
//    assert(b.z == 4)
//    a.x = 5
//    a.y = 6
//    assert(b.x == 5)
//    assert(b.y == 3)
//    assert(b.z == 4)
//    let c = merge(struct { w: 10}, b)
//    assert(c.w == 10)
//    assert(c.x == 5)
//    assert(c.y == 3)
//    assert(c.z == 4)
//    a.x = 7
//    b.z = 11
//    assert(c.w == 10)
//    assert(c.x == 7)
//    assert(c.y == 3)
//    assert(c.z == 11)
//
//    let z = merge(struct { a: 1}, struct { b: 2}, struct { c: 3}, struct { d: 4})
//    assert(struct { a: 1, b: 2, c: 3, d: 4} == z)
//}

fn testIterator() {
    
    // list
    fail(|| => [].iter().get(), 'NoSuchElement')
    let count = 0
    let itr = [1, 2, 3].iter()
    fail(|| => itr.get(), 'NoSuchElement')
    while itr.next() {
        count += itr.get()
    }
    assert(6 == count)
    fail(|| => itr.get(), 'NoSuchElement')

//    // range
//    fail(|| => range(0, 0).iter().get(), 'NoSuchElement')
//    count = 0
//    itr = range(1, 5).iter()
//    fail(|| => itr.get(), 'NoSuchElement')
//    while itr.next() {
//        count += itr.get()
//    }
//    assert(10 == count)
//    fail(|| => itr.get(), 'NoSuchElement')
//
//    // dict
//    fail(|| => dict{}.iter().get(), 'NoSuchElement')
//    count = 0
//    itr = dict{'a': 1, 'b': 2}.iter()
//    fail(|| => itr.get(), 'NoSuchElement')
//    while itr.next() {
//        let e = itr.get()
//        // let (k, v) = itr.get() TODO this would be cool
//        count += e[1]
//    }
//    assert(3 == count)
//    fail(|| => itr.get(), 'NoSuchElement')
//
//    // set
//    fail(|| => set{}.iter().get(), 'NoSuchElement')
//    count = 0
//    itr = set{3, 4, 1, 4}.iter()
//    fail(|| => itr.get(), 'NoSuchElement')
//    while itr.next() {
//        count += itr.get()
//    }
//    assert(8 == count)
//    fail(|| => itr.get(), 'NoSuchElement')
//
//    // str
//    fail(|| => ''.iter().get(), 'NoSuchElement')
//    count = ''
//    itr = 'abcde'.iter()
//    fail(|| => itr.get(), 'NoSuchElement')
//    while itr.next() {
//        count = itr.get() + count
//    }
//    assert('edcba' == count)
//    fail(|| => itr.get(), 'NoSuchElement')
}

fn testInvokeField() {
    let s = 'abc'
    let c = s.contains
    let x = c('b')
    let y = s.contains('z')

    let ls = [1]
    let p = ls.iter().next()

    assert([true, false, true] == [x, y, p])
}

fn main(args) {

    testExpressions()
    testAssignment()
    testFlowControl()

//    testFunc()
//    testCapture()
//    testNamedFunc()
//    testLambda()
//    testStr()
    testList()
//    testFreeze()
//    testDict()
//    testSet()
//    testTuple()
//    testTypes()
//    testGo()
//    testFields()
//    testArity()
//    testRange()
//    testSlice()
//    testUnicodeEscape()
    testStruct()
//    testMerge()

//    testIterator()
    testInvokeField()

//
//    assert(42 == zork.quux)
//
}

