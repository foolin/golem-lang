// Copyright 2018 The Golem Language Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

import zork

fn fail(func, err) {
    try {
        func()
        assert(false)
    } catch e {
        //println(e.error)
        assert(err == e.error)
    }
}

fn listify(ibl) {
    const ls = []
    for n in ibl {
        ls.add(n)
    }
    return ls
}

fn iterate(ibl) {
    const ls = []
    const itr = iter(ibl)
    fail(|| => itr.get(), 'NoSuchElement')
    while itr.next() {
        ls.add(itr.get())
    }
    fail(|| => itr.get(), 'NoSuchElement')
    return ls
}

fn testExpressions() {

    assert((2 + 3) * -4 / 10 == -2)
    assert((2*2*2*2 + 2*3*(8 - 1) + 2) / (17 - 2*2*2 - -1) == 6)

    assert(true + 'a' == 'truea')
    assert('a' + true == 'atrue')
    assert('a' + null == 'anull')
    assert(null + 'a' == 'nulla')

    assert("\n\"abc\"\ndef" == `
"abc"
def`)

    fail(|| => true + null, 'TypeMismatch: Expected Int or Float, not Bool')
    fail(|| => 1 + null, 'TypeMismatch: Expected Int or Float, not Null')
    fail(|| => null + 1, 'TypeMismatch: Expected Int or Float, not Null')

    assert((true == 'a') == false)
    assert((3 * 7 + 4 == 5 * 5) == true)
    assert((1 != 1) == false)
    assert((1 != 2) == true)

    assert(!false == true)
    assert(!true == false)
    fail(|| => !null, 'TypeMismatch: Expected Bool, not Null')
    fail(|| => !'a', 'TypeMismatch: Expected Bool, not Str')
    fail(|| => !1, 'TypeMismatch: Expected Bool, not Int')
    fail(|| => !1.0, 'TypeMismatch: Expected Bool, not Float')

    assert(1 < 2 == true)
    assert(1 <= 2 == true)
    assert(1 > 2 == false)
    assert(1 >= 2 == false)

    assert(2 < 2 == false)
    assert(2 <= 2 == true)
    assert(2 > 2 == false)
    assert(2 >= 2 == true)

    assert(1 <=> 2 == -1)
    assert(2 <=> 2 == 0)
    assert(2 <=> 1 == 1)

    assert((true  && true) == true)
    assert((true  && false) == false)
    assert((false && true) == false)
    assert((false && 12) == false)
    fail(|| => 12 && false, 'TypeMismatch: Expected Bool, not Int')

    assert(true  || (true == true))
    assert(true  || (false == true))
    assert(false || (true == true))
    assert(false || (false == false))
    assert(true  || (12 == true))
    fail(|| => 12  || true, 'TypeMismatch: Expected Bool, not Int')

    assert(~0 == -1)
    assert(8 % 2 == 0)
    assert(8 & 2 == 0)
    assert(8 | 2 == 10)
    assert(8 ^ 2 == 10)
    assert(8 << 2 == 32)
    assert(8 >> 2 == 2)

    assert([-3,1,1,-1,-3,-7] == [~2, ~-2, 7 % -3, -11 % 2, -4 | -3, -17 ^ 22])

    fail(|| => 1 << -1, 'InvalidArgument: Shift count cannot be less than zero')
    fail(|| => 1 >> -1, 'InvalidArgument: Shift count cannot be less than zero')

    assert([true][0] == true)
    assert('abc'[1] == 'b')
    assert('abc'[-1] == 'c')
    fail(|| => 'abc'[3], 'IndexOutOfBounds: 3')
    fail(|| => [true][2], 'IndexOutOfBounds: 2')
    fail(|| => (1,2)[3], 'IndexOutOfBounds: 3')
    fail(|| => range(0, 2)[2], 'IndexOutOfBounds: 2')

    assert('abc'[1:] == 'bc')
    assert('abc'[:1] == 'a')
    assert('abcd'[1:3] == 'bc')
    assert('abcd'[1:1] == '')

    assert([6,7,8][1:] == [7,8])
    assert([6,7,8][:1] == [6])
    assert([6,7,8,9][1:3] == [7,8])
    assert([6,7,8,9][1:1] == [])

    fail(|| => len(true), 'TypeMismatch: Type Bool has no len()')
    fail(|| => true[0], 'TypeMismatch: Type Bool cannot be indexed')
    fail(|| => true[0] = 1, 'TypeMismatch: Type Bool cannot be indexed')
    fail(|| => true[0:1], 'TypeMismatch: Type Bool cannot be sliced')
    fail(|| => true[:1], 'TypeMismatch: Type Bool cannot be sliced')
    fail(|| => true[0:], 'TypeMismatch: Type Bool cannot be sliced')
    fail(|| => set {} < 3, 'TypeMismatch: Types Set and Int cannot be compared')
    fail(|| => 3 > set {}, 'TypeMismatch: Types Int and Set cannot be compared')
}

fn testInt() {
    assert(1 == 1)
    assert(2 == 2)
    assert(1 != 2)
    assert(2 != 1)
    assert(1 != 'z')
    assert('z' != 2)

    assert(frozen(1))
    assert(1 == freeze(1))
    assert(frozen(1))

    fail(|| => iter(1), "TypeMismatch: Type Int has no iter()")
    fail(|| => len(1), "TypeMismatch: Type Int has no len()")

    assert('1' == str(1))
    assert('Int' == type(1))

    assert(set {} == fields(1))
    assert(!hasField(1, 'bogus'))
    fail(|| => 1 .bogus, "NoSuchField: Field 'bogus' not found") // Note that '1.bogus' fails to parse
    fail(|| => getField(1, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => setField(1, 'bogus', null), "TypeMismatch: Expected Struct, not Int")
    fail(|| => 1 .bogus = 'z', "TypeMismatch: Expected Struct, not Int")
}

fn testFloat() {
    assert(1.1 == 1.1)
    assert(2.2 == 2.2)
    assert(1.1 != 2.2)
    assert(2.2 != 1.1)
    assert(1.1 != 'z')
    assert('z' != 2.2)

    assert(frozen(1.1))
    assert(1.1 == freeze(1.1))
    assert(frozen(1.1))

    fail(|| => iter(1.1), "TypeMismatch: Type Float has no iter()")
    fail(|| => len(1.1), "TypeMismatch: Type Float has no len()")

    assert('1.1' == str(1.1))
    assert('Float' == type(1.1))

    assert(set {} == fields(1.1))
    assert(!hasField(1.1, 'bogus'))
    fail(|| => 1.1 .bogus, "NoSuchField: Field 'bogus' not found") // Note that '1.1.bogus' fails to parse
    fail(|| => getField(1.1, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => setField(1.1, 'bogus', null), "TypeMismatch: Expected Struct, not Float")
    fail(|| => 1.1 .bogus = 'z', "TypeMismatch: Expected Struct, not Float")

    assert(1.0 + 2.0 == 3.0)
    assert(1.0 - 2.0 == -1.0)
    assert(3.0 * 2.0 == 6.0)
    assert(3.0 / 2.0 == 1.5)
    fail(|| => 3.0 / 0.0, 'DivideByZero')
}

fn testAssignment() {
    const funcs = [
        fn () {
            let a = 1
            const b = 2
            a = a + b
            assert([3, 2] == [a, b])
        },
        fn () {
            let a = 1
            a = a + 41
            const b = a / 6
            let c = b + 3
            c = (c + a)/13
            assert([42, 7, 4] == [a, b, c])
        },
        fn () {
            let a = 1
            let b = a += 3
            let c = ~0
            c -= -2
            c <<= 4
            b *= 2
            assert([4, 8, 16] == [a, b, c])
        },
        fn () {
            let a = 1
            let b = 2
            a = b = 11
            b = a %= 4
            assert([3, 3] == [a, b])
        },
        fn () {
            let a = 10
            let b = 20
            const c = a++
            const d = b--
            assert([11, 19, 10, 20] == [a, b, c, d])

            fail(fn() {
                    let e = 'abc'
                    e++
                }, "TypeMismatch: Expected Int or Float, not Str")
        },
        fn () {
            const a = [10]
            const b = [20]
            const c = a[0]++
            const d = b[0]--
            assert([[11], [19], 10, 20] == [a, b, c, d])

            fail(fn() {
                    const e = ['abc']
                    e[0]++
                }, "TypeMismatch: Expected Int or Float, not Str")
        },
        fn () {
            const a = struct { x: 10 }
            const b = struct { y: 20 }
            const c = a.x++
            const d = b.y--
            assert([struct { x: 11 }, struct { y: 19 }, 10, 20] == [a, b, c, d])

            fail(fn() {
                    const e = struct { x: 'abc' }
                    e.x++
                }, "TypeMismatch: Expected Int or Float, not Str")
        }
    ]
    for f in funcs { f(); }
}

//fn testTry() {
//    println('testTry')
//
//    const funcs = [
//        fn () {
//            println('begin func 0')
//            fail(|| => 3 / 0, "DivideByZero")
//            fail(fn() {
//                    try {
//                        3 / 0
//                    } catch e2 {
//                        assert()
//                    }
//                },
//                "ArityMismatch: Expected 1 params, got 0")
//            println('end   func 0')
//        },
//        fn () {
//            println('begin func 1')
//            const a = 0
//            const b = 0
//            try {
//                3 / 0
//            } catch e {
//                a = 1
//            }
//            try {
//                3 / 0
//            } catch e {
//                b = 2
//            }
//            assert(a == 1)
//            assert(b == 2)
//            println('end   func 1')
//        },
//        fn () {
//            println('begin func 2')
//            const a = 0
//            try {
//                3 / 0
//            } catch e {
//                a = 1
//            } finally {
//                a = 2
//            }
//            assert(a == 2)
//            println('end   func 2')
//        },
//        fn () {
//            println('begin func 3')
//            const a = 0
//            //const f = fn() {
//            //    try {
//            //        3 / 0
//            //    } catch e {
//            //        return 1
//            //    } finally {
//            //        a = 2
//            //    }
//            //}
//            //const b = f()
//            //assert(b == 1)
//            //assert(a == 2)
//            println('end   func 3')
//        },
//        fn () {
//            println('begin func 4')
//            //const a = 0
//            //const f = fn() {
//            //    try {
//            //        3 / 0
//            //    } catch e {
//            //        return 1
//            //    } finally {
//            //        a = 2
//            //    }
//            //}
//            //const b = f()
//            //assert(b == 1)
//            //assert(a == 2)
//            println('end   func 4')
//        }
//        //fn () {
//        //    println('func 4')
//        //    const a = 0
//        //    const b = 0
//        //    //try {
//        //    //    try {
//        //    //        3 / 0
//        //    //    } catch e {
//        //    //        assert(1,2,3)
//        //    //    } finally {
//        //    //        a = 1
//        //    //    }
//        //    //} catch e {
//        //    //    b = 2
//        //    //}
//        //    //assert(a == 1)
//        //    //assert(b == 2)
//        //}
//        ////fn () {
//        ////    println('throw test')
//        ////    //try {
//        ////        //throw 'abcdef';
//        ////        //assert(false)
//        ////    //} catch e {
//        ////    //    println(e)
//        ////    //}
//        ////}
//    ]
//    println('len funcs ', len(funcs))
//
//    //funcs[0]()
//    //funcs[1]()
//    //funcs[2]()
//    funcs[3]()
//    funcs[4]()
//
//    //for i in range(0, len(funcs)) {
//    //    const f = funcs[i]
//    //    println('testing ', i, ': ', f)
//    //    f()
//    //}
//    
//    //for f in funcs { 
//    //    println('testing ', f)
//    //    f() 
//    //}
//}

fn testFlowControl() {
    const funcs = [
        fn () {
            let a = 1; if (true) { a = 2; }
            assert(a == 2)
        },
        fn () {
            let a = 1; if (false) { a = 2; }
            assert(a == 1)
        },
        fn () {
            let a = 1; if (1 == 1) { a = 2; } else { a = 3; }; const b = 4;
            assert(a == 2 && b == 4)
        },
        fn () {
            let a = 1; if (1 == 2) { a = 2; } else { a = 3; }; const b = 4;
            assert(a == 3 && b == 4)
        },
        fn () {
            const a = true ? 3 : 4;
            const b = false ? 5 : 6;
            assert(a == 3 && b == 6)
        },
        fn () {
            let a = 1
            while (a < 3) {
                a = a + 1
            }
            assert(a == 3)
        },
        fn () {
            let a = 1
            while (a < 11) {
                if (a == 4) { a = a + 2; break; }
                a = a + 1
            }
            assert(a == 6)
        },
        fn () {
            let a = 1
            let b = 0
            while (a < 11) {
                a = a + 1
                if (a > 5) { continue; }
                b = b + 1
            }
            assert(a == 11 && b == 4)
        },
        fn () {
            let s = ''
            for i in range(0, 4) {
                switch {
                case i == 0:
                    s += 'a'

                case i == 1, i == 2:
                    s += 'b'

                default:
                    s += 'c'
                }
            }
            assert(s == 'abbc')
        },
        fn () {
            let s = ''
            for i in range(0, 4) {
                switch {
                case i == 0, i == 1:
                    s += 'a'

                case i == 2:
                    s += 'b'
                }
            }
            assert(s == 'aab')
        },
        fn () {
            let s = ''
            for i in range(0, 4) {
                switch i {
                case 0, 1:
                    s += 'a'

                case 2:
                    s += 'b'
                }
            }
            assert(s == 'aab')
        }
    ]
    for f in funcs { f(); }
}

fn testFunc() {

    const f = || => null
    const g = || => null

    assert(f == f)
    assert(g == g)
    assert(f != g)
    assert(g != f)
    assert(f != 'z')
    assert('z' != g)

    assert(frozen(f))
    assert(f == freeze(f))
    assert(frozen(f))

    fail(|| => iter(f), "TypeMismatch: Type Func has no iter()")
    fail(|| => len(f), "TypeMismatch: Type Func has no len()")

    assert(str(f).hasPrefix('func<'))
    assert('Func' == type(f))

    assert(set {} == fields(f))
    assert(!hasField(f, 'bogus'))
    fail(|| => f.bogus, "NoSuchField: Field 'bogus' not found")
    fail(|| => getField(f, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => setField(f, 'bogus', null), "TypeMismatch: Expected Struct, not Func")
    fail(|| => f.bogus = 'z', "TypeMismatch: Expected Struct, not Func")

    //------------------------------------------

    let a = fn(x) { x; }
    let b = a(1)
    assert(b == 1)

    a = fn() { }
    b = fn(x) { x; }
    const c = fn(x, y) { const z = 4; x * y * z; }
    const d = a()
    const e = b(1)
    const h = c(b(2), 3)
    assert([null, 1, 24] == [d, e, h])

    const fibonacciGenerator = fn() {
        let x = 1
        let y = 1
        return fn() {
            const z = x
            x = y
            y = x + z
            return z
        }
    }
    const fg = fibonacciGenerator()
    const list = []
    for i in range(0, 10) {
        list.add(fg())
    }
    assert([1, 1, 2, 3, 5, 8, 13, 21, 34, 55] == list)

    const foo = fn(n) {
        const bar = fn(x) {
            return x * (x - 1)
        }
        return bar(n) + bar(n-1)
    }
    assert(32 == foo(5))

    fail(|| => 1/0, 'DivideByZero')
    fail(|| => true(), 'TypeMismatch: Expected Func, not Bool')
}

fn testCapture() {

    const accumGen = fn(n) {
        return fn(i) {
            n = n + i
            return n
        }
    }
    const a = accumGen(3)
    const x = a(2)
    const y = a(7)
    assert([5, 12] == [x, y])

    //---------------------

    let z = 2
    const acc2 = fn(n) {
        return fn(i) {
            n = n + i
            n = n + z
            return n
        }
    }
    const b = acc2(3)
    const i = b(2)
    z = 0
    const j = b(1)
    assert([0, 7, 8] == [z, i, j])

    const m = 123
    const n = 456

    fn foo() {
        assert(n == 456)
        assert(m == 123)
    }
    foo()

    //---------------------

    const cap = 1
    const f1 = || => cap
    const f2 = || => cap
    assert([1, 1] == [f1(), f2()])
}

fn testNamedFunc() {
    fn a() {
        return b()
    }
    fn b() {
        return 42
    }
    assert(a() == 42)
}

fn testLambda() {
    const z = 5
    const a = || => 3
    const b = |x| => x * x
    const c = |x, y| => (x + y)*z
    assert(a() == 3)
    assert(b(2) == 4)
    assert(c(1, 2) == 15)
}

fn testNull() {

    assert(null == null)
    assert(null != 1)
    assert(1 != null)

    fail(|| => freeze(null), "NullValue")
    fail(|| => frozen(null), "NullValue")
    fail(|| => iter(null), "NullValue")
    fail(|| => len(null), "NullValue")
    fail(|| => range(null, null), "NullValue")
    assert('null' == str(null)) // this is convenient
    fail(|| => type(null), "NullValue")

    fail(|| => fields(null), "NullValue")
    fail(|| => hasField(null, 'bogus'), "NullValue")

    fail(|| => getField(null, 'bogus'), "NullValue")
    fail(|| => null.bogus, "NullValue")
    fail(|| => null.bogus(), "NullValue")
    fail(|| => setField(null, 'bogus', null), "NullValue")
    fail(|| => null.bogus = 1, "NullValue")
}

fn testBool() {

    assert(true == true)
    assert(false == false)
    assert(true != false)
    assert(false != true)
    assert(true != 1)
    assert(1 != false)

    assert(frozen(true))
    assert(frozen(false))
    assert(true == freeze(true))
    assert(false == freeze(false))
    assert(frozen(true))
    assert(frozen(false))

    fail(|| => iter(true), "TypeMismatch: Type Bool has no iter()")
    fail(|| => iter(false), "TypeMismatch: Type Bool has no iter()")
    fail(|| => len(true), "TypeMismatch: Type Bool has no len()")
    fail(|| => len(false), "TypeMismatch: Type Bool has no len()")

    fail(|| => range(true, 1), "TypeMismatch: Expected Int, not Bool")
    fail(|| => range(false, 1), "TypeMismatch: Expected Int, not Bool")
    fail(|| => range(1, true), "TypeMismatch: Expected Int, not Bool")
    fail(|| => range(1, false), "TypeMismatch: Expected Int, not Bool")

    assert('true' == str(true))
    assert('false' == str(false))

    assert('Bool' == type(true))
    assert('Bool' == type(false))

    assert(set{} == fields(true))
    assert(set{} == fields(false))

    assert(false == hasField(true, 'bogus'))
    assert(false == hasField(false, 'bogus'))

    fail(|| => getField(true,  'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => getField(false, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => true.bogus, "NoSuchField: Field 'bogus' not found")
    fail(|| => false.bogus, "NoSuchField: Field 'bogus' not found")
    fail(|| => true.bogus(), "NoSuchField: Field 'bogus' not found")
    fail(|| => false.bogus(), "NoSuchField: Field 'bogus' not found")

    fail(|| => setField(true, 'bogus', null), "TypeMismatch: Expected Struct, not Bool")
    fail(|| => setField(false, 'bogus', null), "TypeMismatch: Expected Struct, not Bool")
    fail(|| => true.bogus = 1,  "TypeMismatch: Expected Struct, not Bool")
    fail(|| => false.bogus = 1, "TypeMismatch: Expected Struct, not Bool")
}

fn testStr() {

    assert('a' == 'a')
    assert('b' == 'b')
    assert('a' != 'b')
    assert('b' != 'a')
    assert('a' != 1)
    assert(1 != 'b')

    assert(frozen('a'))
    assert('a' == freeze('a'))
    assert(frozen('a'))

    assert(iter('a') != null)
    assert(1 == len('a'))

    fail(|| => range('a', 1), "TypeMismatch: Expected Int, not Str")
    fail(|| => range(1, 'a'), "TypeMismatch: Expected Int, not Str")

    assert('a' == str('a'))
    assert('Str' == type('a'))

    let s = 'a'
    assert(set { 
        'contains', 'index', 'lastIndex', 
        'hasPrefix', 'hasSuffix',
        'replace', 'split'
    } == fields(s))
    for f in fields(s) {
        assert(hasField(s, f))
    }
    assert(s.contains == getField(s, 'contains'))
    assert(s.index == getField(s, 'index'))
    assert(s.lastIndex == getField(s, 'lastIndex'))
    assert(s.hasPrefix == getField(s, 'hasPrefix'))
    assert(s.hasSuffix == getField(s, 'hasSuffix'))
    assert(s.replace == getField(s, 'replace'))
    assert(s.split == getField(s, 'split'))

    assert(!hasField(s, 'bogus'))
    fail(|| => getField(s, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => setField(s, 'bogus', null), "TypeMismatch: Expected Struct, not Str")
    fail(|| => s.bogus = 1, "TypeMismatch: Expected Struct, not Str")

    //---------------------------------------------

    s = '34é€™';
    assert(s[0:1] == '3');
    assert(s[1:3] == '4é€™');
    assert(s[-2:-1] == '4');
    assert(s[-5:-4] == '');
    assert(s[3:4] == '');

    s = '\u{1f496}\u{2665}\u{24}'
    assert('ğŸ’–' == s[0])
    assert('â™¥'  == s[1])
    assert('$'  == s[2])

    assert(listify(s) == ['ğŸ’–', 'â™¥', '$'])
    assert(iterate(s) == ['ğŸ’–', 'â™¥', '$'])
    assert(listify('abc') == ['a', 'b', 'c'])
    assert(iterate('abc') == ['a', 'b', 'c'])
    assert(listify('') == [])
    assert(iterate('') == [])

    // This is some chinese text that we are going to use for testing purposes.
    // é€™æ˜¯æˆ‘å€‘å°‡ç”¨æ–¼æ¸¬è©¦ç›®çš„çš„ä¸€äº›ä¸­æ–‡æ–‡æœ¬ã€‚

    s = "é€™æ˜¯æˆ‘å€‘abc"
    assert(7 == len(s))
    let reverse = ''  
    for c in s {
        reverse = c + reverse
    }
    assert('cbaå€‘æˆ‘æ˜¯é€™' == reverse)

    fail(|| => iter('').get(), 'NoSuchElement')
    const count = 0
    const itr = iter(s)
    fail(|| => itr.get(), 'NoSuchElement')
    reverse = ''  
    while itr.next() {
        reverse = itr.get() + reverse
    }
    assert('cbaå€‘æˆ‘æ˜¯é€™' == reverse)
    fail(|| => itr.get(), 'NoSuchElement')

    const f = s.contains
    assert(true == f('ab'))
    assert(true == s.contains('é€™æ˜¯æˆ‘'))
    assert(true == s.contains('å€‘ab'))
    assert(false == s.contains('z'))
    assert(true == 'abcde'.contains('cd'))
    assert(true == 'abcde'.contains('d'))
    assert(false == ''.contains('cd'))
    assert(false == ''.contains('d'))
	fail(|| => s.contains(), 'ArityMismatch: Expected 1 params, got 0')
	fail(|| => s.contains(1), 'TypeMismatch: Expected Str, not Int')

    assert(0 == s.index('é€™æ˜¯æˆ‘'))
    assert(3 == s.index('å€‘ab'))
    assert(-1 == s.index('z'))
    assert(2 == 'abcde'.index('cd'))
    assert(3 == 'abcde'.index('d'))
    assert(-1 == ''.index('cd'))
    assert(-1 == ''.index('d'))
	fail(|| => s.index(), 'ArityMismatch: Expected 1 params, got 0')
	fail(|| => s.index(1), 'TypeMismatch: Expected Str, not Int')

    s = "é€™æ˜¯æˆ‘å€‘aå€‘abc"
    assert(0 == s.lastIndex('é€™æ˜¯æˆ‘'))
    assert(5 == s.lastIndex('å€‘a'))
    assert(-1 == s.lastIndex('z'))
    assert(2 == 'abcde'.lastIndex('cd'))
    assert(5 == 'abcdcde'.lastIndex('d'))
    assert(-1 == ''.lastIndex('cd'))
    assert(-1 == ''.lastIndex('d'))
	fail(|| => s.lastIndex(), 'ArityMismatch: Expected 1 params, got 0')
	fail(|| => s.lastIndex(1), 'TypeMismatch: Expected Str, not Int')

    assert(s.hasPrefix('é€™æ˜¯æˆ‘'))
    assert(!s.hasPrefix('bc'))
    assert(!''.hasPrefix('é€™æ˜¯æˆ‘'))
    assert(!''.hasPrefix('bc'))
	fail(|| => s.lastIndex(), 'ArityMismatch: Expected 1 params, got 0')
	fail(|| => s.lastIndex(1), 'TypeMismatch: Expected Str, not Int')

    assert(!s.hasSuffix('é€™æ˜¯æˆ‘'))
    assert(s.hasSuffix('bc'))
    assert(!''.hasSuffix('é€™æ˜¯æˆ‘'))
    assert(!''.hasSuffix('bc'))
	fail(|| => s.lastIndex(), 'ArityMismatch: Expected 1 params, got 0')

    assert("é€™æ˜¯æˆ‘zzbc" == s.replace('å€‘a', 'z'))
    assert("é€™æ˜¯æˆ‘zå€‘abc" == s.replace('å€‘a', 'z', 1))
    assert('abc' == 'abc'.replace('x', 'y'))
	fail(|| => s.replace(), 'ArityMismatch: Expected at least 2 params, got 0')

    assert(['a', 'b', 'c'] == 'a,b,c'.split(','))
    assert(['abc'] == 'abc'.split(','))
    assert([''] == ''.split(','))
	fail(|| => s.split(), 'ArityMismatch: Expected 1 params, got 0')
}

fn testList() {

    assert([] == [])
    assert([1] == [1])
    assert([1,2] == [1,2])
    assert([1,2,3] == [1,2,3])
    assert([1,2,3] != [1,2,4])
    assert([1,2,3] != [1,2])
    assert([1,2,3] != [1])
    assert([1,2,3] != [])

    const x = []
    const y = [1]

    assert(x == x)
    assert(y == y)
    assert(x != y)
    assert(y != x)
    assert(x != 'z')
    assert('z' != y)

    assert(!frozen(x))
    assert(x == freeze(x))
    assert(frozen(x))
    fail(|| => x.add(1), "ImmutableValue")
    fail(|| => x.addAll(1), "ImmutableValue")
    fail(|| => x.remove(1), "ImmutableValue")
    fail(|| => x.clear(), "ImmutableValue")
    x.isEmpty()
    x.contains(1)
    x.indexOf(1)
    x.map(|e| => e)
    x.reduce(0, |acc, e| => acc + e)
    x.filter(|e| => e)

    assert(iter(x) != null)
    assert(len(x) == 0)
    assert(len(y) == 1)

    assert("[ ]" == str([]))
    assert("[ 1 ]" == str([1]))
    assert("[ 1, 2 ]" == str([1,2]))

    assert('List' == type(x))

    assert(set { 
        'isEmpty', 
        'contains', 
        'indexOf', 
        'join',
        'map',
        'reduce',
        'filter',

        'add', 
        'addAll',
        'clear',
        'remove' 
    } == fields(x))
    for f in fields(x) {
        assert(hasField(x, f))
    }
    assert(x.isEmpty == getField(x, 'isEmpty'))
    assert(x.contains == getField(x, 'contains'))
    assert(x.join == getField(x, 'join'))
    assert(x.indexOf == getField(x, 'indexOf'))
    assert(x.map == getField(x, 'map'))
    assert(x.reduce == getField(x, 'reduce'))
    assert(x.filter == getField(x, 'filter'))

    assert(x.add == getField(x, 'add'))
    assert(x.addAll == getField(x, 'addAll'))
    assert(x.clear == getField(x, 'clear'))
    assert(x.remove == getField(x, 'remove'))

    assert(!hasField(x, 'bogus'))
    fail(|| => getField(x, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => setField(x, 'bogus', null), "TypeMismatch: Expected Struct, not List")
    fail(|| => x.bogus = 1, "TypeMismatch: Expected Struct, not List")

    //-------------------------------------------------

    const funcs = [
        fn () {
            let count = 0
            for n in [1, 2, 3] {
                count += n
            }
            assert(6 == count)
        },
        fn () {
            fail(|| => iter([]).get(), 'NoSuchElement')
            let count = 0
            const itr = iter([1, 2, 3])
            fail(|| => itr.get(), 'NoSuchElement')
            while itr.next() {
                count += itr.get()
            }
            assert(6 == count)
            fail(|| => itr.get(), 'NoSuchElement')
        },
        fn () {
            const a = []
            const b = [true]
            const c = [false,22]
            const d = b[0]
            b[0] = 33
            const e = c[1]++
            assert([[], [ 33 ], [ false, 23 ], true, 22] == [a, b, c, d, e])
        },
        fn () {
            const a = []
            a.add(1)
            assert(a == [1])
            a.add(2).add([3])
            assert(a == [1,2,[3]])
            const b = []
            b.add(null)
            assert(b == [null])
            assert(a.add == a.add)
            assert(b.add == b.add)
            assert(a.add != b.add)
            assert(b.add != a.add)

            const f = b.add
            f(5)
            assert(b == [null, 5])

            assert(b.remove(1) == [null])
        },
        fn () {
            const a = []
            a.addAll([1,null]).addAll('bc').addAll([])
            assert(a == [1,null,'b','c'])
        },
        fn () {
            const a = []
            assert(a.isEmpty())
            a.add(1)
            assert(!a.isEmpty())
            a.clear()
            assert(a.isEmpty())
        },
        fn () {
            let a = []
            assert(!a.contains('x'))
            assert(a.indexOf('x') == -1)
            a = ['z', 'x']
            assert(a.contains('x'))
            assert(a.indexOf('x') == 1)
        },
        fn () {
            const a = [1, 2, 3]
        },
        fn () {
            const a = []
            assert(a.join() == '')
            assert(a.join(',') == '')
            a.add(1)
            assert(a.join() == '1')
            assert(a.join(',') == '1')
            a.add(2)
            assert(a.join() == '12')
            assert(a.join(',') == '1,2')
            a.add('abc')
            assert(a.join() == '12abc')
            assert(a.join(',') == '1,2,abc')
        },
        fn () {
            const ls = [1, 2, 3, 4, 5]
            const squares = ls.map(|x| => x * x)
            const addedUp = ls.reduce(0, |acc, x| => acc + x)
            const even = ls.filter(|x| => (x % 2 == 0))

            assert(squares == [1, 4, 9, 16, 25])
            assert(addedUp == 15)
            assert(even == [2, 4])

            ls.remove(2)
            assert(ls == [1, 2, 4, 5])
        },
        fn () {
            const ls = [3, 4, 5]
            assert(ls[0] == 3)
            assert(ls[2] == 5)
            assert(ls[0:3] == [3, 4, 5])
            assert(ls[2:3] == [5])
            const a = [1, 2, 3]
            let n = 0
            const b = a.map(fn(x) { n += x; x*x; })
            assert(b == [1, 4, 9] && n == 6)

            fail(|| => [].remove('a'), 'TypeMismatch: Expected Int, not Str')
        },
        fn () {
            const ls = [3,4,5];
            assert(ls[0:1] == [3]);
            assert(ls[1:3] == [4,5]);
            assert(ls[-2:-1] == [4]);
            assert(ls[-5:-4] == []);
            assert(ls[3:4] == []);

            const a = [1, 2, 3]
            assert([false, false, false, false] == [a, a[0:1], a[0:], a[:1]].map(frozen))
            freeze(a)
            assert([true, true, true, true] == [a, a[0:1], a[0:], a[:1]].map(frozen))
        },
        fn () {
            const a = set {11, 2, 31, 4, 5}
            const b = [].addAll(a)
            const c = set{}.addAll(b)
            assert(a == c)

            const d = dict {'x': 1, 2: 'y'}
            const e = set{}.addAll(d)
            const f = [].addAll(e)
            const g = dict{}.addAll(f)
            assert(d == g)
        },
        fn () {
            const a = set{1, 2, 3, 4, 5}
            const b = [].addAll(a).map(|e| => ((e, e*e), (e*e*e)))
            const c = dict{}.addAll(b)
            const d = [].addAll(c)

            const e = set{}
            for t in d {
                e.add(t[0][0])
                e.add(t[0][1])
                e.add(t[1])
            }

            assert(b == [ ((1, 1), 1), ((2, 4), 8), ((3, 9), 27), ((4, 16), 64), ((5, 25), 125) ])
            assert(c == dict{ (1, 1): 1, (2, 4): 8, (3, 9): 27, (4, 16): 64, (5, 25): 125 })
            assert(e == set { 1, 2, 3, 4, 5, 8, 9, 16, 64, 25, 27, 125 })
        }
    ]
    for f in funcs { f(); }
}

fn testDict() {

    assert(dict {} == dict{})
    assert(dict {'a': 1} == dict{'a': 1})
    assert(dict {'a': 1, 'b': 2} == dict{'a': 1, 'b': 2})
    assert(dict {'a': 1, 'b': 2, 'c': 3} == dict{'a': 1, 'b': 2, 'c': 3})

    assert(dict {'a': 1, 'b': 2, 'c': 3} != dict{'a': 1, 'b': 2, 'd': 4})
    assert(dict {'a': 1, 'b': 2, 'c': 3} != dict{'a': 1, 'b': 2})
    assert(dict {'a': 1, 'b': 2, 'c': 3} != dict{'a': 1})
    assert(dict {'a': 1, 'b': 2, 'c': 3} != dict{})

    const x = dict{}
    const y = dict{'a': 1}

    assert(x == x)
    assert(y == y)
    assert(x != y)
    assert(y != x)
    assert(x != 'z')
    assert('z' != y)

    assert(!frozen(x))
    assert(x == freeze(x))
    assert(frozen(x))
    fail(|| => x.addAll(1), "ImmutableValue")
    fail(|| => x.remove(1), "ImmutableValue")
    fail(|| => x.clear(), "ImmutableValue")
    x.isEmpty()
    x.contains(1)

    assert(iter(x) != null)
    assert(len(x) == 0)
    assert(len(y) == 1)

    assert("dict { }" == str(dict {}))
    assert("dict { 1: a }" == str(dict {1:'a'}))
    assert("dict { 1: a, 2: b }" == str(dict {1:'a',2:'b'}))

    assert('Dict' == type(x))

    assert(set { 
        'isEmpty', 
        'contains', 

        'addAll',
        'clear',
        'remove' 
    } == fields(x))
    for f in fields(x) {
        assert(hasField(x, f))
    }
    assert(x.isEmpty == getField(x, 'isEmpty'))
    assert(x.contains == getField(x, 'contains'))

    assert(x.addAll == getField(x, 'addAll'))
    assert(x.clear == getField(x, 'clear'))
    assert(x.remove == getField(x, 'remove'))

    assert(!hasField(x, 'bogus'))
    fail(|| => getField(x, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => setField(x, 'bogus', null), "TypeMismatch: Expected Struct, not Dict")
    fail(|| => x.bogus = 1, "TypeMismatch: Expected Struct, not Dict")

    //-------------------------------------------------

    const funcs = [
        fn () {
            const d = dict {'x': 1, 'y': 2};
            d['x'] = 0;
            assert(d == dict {'y': 2, 'x': 0});
        },
        fn () {
            const a = dict { 'x': 1, 'y': 2 };
            const b = a['x'];
            const c = a['z'];
            a['x'] = -1;
            const d = a['x'];
            assert([1, null, -1] == [b, c, d])
        },
        fn () {
            const a = dict {};
            a.addAll([(1,2)]).addAll([(3,4)]);
            assert(a == dict {1:2,3:4});
            const b = dict {};
            assert(a.addAll == a.addAll);
            assert(b.addAll == b.addAll);
            assert(a.addAll != b.addAll);
            assert(b.addAll != a.addAll);
            assert(a.clear != a.addAll);
        },
        fn () {
            const a = dict{}
            fail(|| => a.addAll(false),      'TypeMismatch: Type Bool has no iter()')
            fail(|| => a.addAll([false]),    'TypeMismatch: Expected Tuple, not Bool')
            fail(|| => a.addAll([(1,2,3)]),  'InvalidArgument: Expected Tuple of length 2, not length 3')
            fail(|| => a[[1,2]],             'TypeMismatch: Type List cannot be hashed')
            fail(|| => a[[1,2]] = 3,         'TypeMismatch: Type List cannot be hashed')
            fail(|| => a.contains([1,2]), 'TypeMismatch: Type List cannot be hashed')
        },
        fn () {
            const a = dict {};
            assert(a.isEmpty());
            a[1] = 2;
            assert(!a.isEmpty());
            a.clear();
            assert(a.isEmpty());
        },
        fn () {
            const a = dict {'z': 3};
            assert(a.contains('z'));
            assert(!a.contains('x'));
        },
        fn () {
            const d = dict {'a': 1, 'b': 2};
            d.remove('z')
            d.remove('a')
            assert(d == dict {'b': 2});
            d.remove('b');
            assert(d == dict {});
            assert(len(d) == 0);
        },
        fn () {
            const d = dict {'a': 1, 'b': 2};
            d.remove('z');
            d.remove('a');
            assert(d == dict {'b': 2});
            d.remove('b');
            assert(d == dict {});
            assert(len(d) == 0);
        },
        fn () {
            const b = []
            b.addAll(range(0,3))
            b.addAll(dict { (true,false): 1, 'y': 2 })
            assert(b == [ 0, 1, 2, ((true,false), 1), ('y', 2)])
        },
        fn () {
            fail(|| => dict {null: 'b'}, 'NullValue')
            fail(|| => dict {[]: 'b'}, 'TypeMismatch: Type List cannot be hashed')
        }
    ]
    for f in funcs { f(); }
}

fn testSet() {

    assert(set {} == set{})
    assert(set {'a'} == set{'a'})
    assert(set {'a', 'b'} == set{'a', 'b'})
    assert(set {'a', 'b', 'c'} == set{'a', 'b', 'c'})

    assert(set {'a', 'b', 'c'} != set{'a', 'b', 'd'})
    assert(set {'a', 'b', 'c'} != set{'a', 'b'})
    assert(set {'a', 'b', 'c'} != set{'a'})
    assert(set {'a', 'b', 'c'} != set{})

    const x = set{}
    const y = set{'a'}

    assert(x == x)
    assert(y == y)
    assert(x != y)
    assert(y != x)
    assert(x != 'z')
    assert('z' != y)

    assert(!frozen(x))
    assert(x == freeze(x))
    assert(frozen(x))
    fail(|| => x.add(1), "ImmutableValue")
    fail(|| => x.addAll(1), "ImmutableValue")
    fail(|| => x.remove(1), "ImmutableValue")
    fail(|| => x.clear(), "ImmutableValue")
    x.isEmpty()
    x.contains(1)

    assert(iter(x) != null)
    assert(len(x) == 0)
    assert(len(y) == 1)

    assert("set { }" == str(set {}))
    assert("set { 1 }" == str(set {1}))
    assert("set { 1, 2 }" == str(set {1,2}))

    assert('Set' == type(x))

    assert(set { 
        'isEmpty', 
        'contains', 

        'add', 
        'addAll',
        'clear',
        'remove' 
    } == fields(x))
    for f in fields(x) {
        assert(hasField(x, f))
    }
    assert(x.isEmpty == getField(x, 'isEmpty'))
    assert(x.contains == getField(x, 'contains'))

    assert(x.add == getField(x, 'add'))
    assert(x.addAll == getField(x, 'addAll'))
    assert(x.clear == getField(x, 'clear'))
    assert(x.remove == getField(x, 'remove'))

    assert(!hasField(x, 'bogus'))
    fail(|| => getField(x, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => setField(x, 'bogus', null), "TypeMismatch: Expected Struct, not Set")
    fail(|| => x.bogus = 1, "TypeMismatch: Expected Struct, not Set")

    //-------------------------------------------------

    const funcs = [
        fn () {
            const a = set {};
            a.add(1);
            assert(a == set {1});
            a.add(2).add(3).add(2);
            assert(a == set {1,2,3});
            assert(set {3,1,2} == set {1,2,3});
            assert(set {1,2} != set {1,2,3});
            const b = set { 4 };
            b.add(4);
            assert(b == set { 4 });
            assert(a.add == a.add);
            assert(b.add == b.add);
            assert(a.add != b.add);
            assert(b.add != a.add);
        },
        fn () {
            const a = set {};
            a.addAll([1,2]).addAll('bc');
            assert(a == set {1,2,'b','c'});
            const b = set {};
            b.addAll(range(0,3));
            assert(b == set { 0, 1, 2 });
            assert(a.addAll == a.addAll);
            assert(b.addAll == b.addAll);
            assert(a.addAll != b.addAll);
            assert(b.addAll != a.addAll);
            assert(a.add != a.addAll);
        },
        fn () {
            fail(|| => set{}.addAll(false),   'TypeMismatch: Type Bool has no iter()')
            fail(|| => set{}.add(3,4),        'ArityMismatch: Expected 1 params, got 2')
            fail(|| => set{}.add([1,2]),      'TypeMismatch: Type List cannot be hashed')
            fail(|| => set{}.contains([1,2]), 'TypeMismatch: Type List cannot be hashed')
            fail(|| => set {'a', 'b', null},  'NullValue')
            fail(|| => set {'a', 'b', []},    'TypeMismatch: Type List cannot be hashed')
        },
        fn () {
            const a = set{};
            assert(a.isEmpty());
            a.add(1);
            assert(!a.isEmpty());
            a.clear();
            assert(a.isEmpty());
        },
        fn () {
            let a = set{};
            assert(!a.contains('x'));
            a = set {'z', 'x'};
        },
        fn () {
            const s = set {'a', 'b', 'c'};
            s.remove('z').remove('a')
            assert(s == set {'c', 'b'});
            s.remove('b');
            assert(s == set {'c'});
            assert(len(s) == 1);
            s.remove('c');
            assert(s == set {});
            assert(len(s) == 0);
        }
    ]
    for f in funcs { f(); }
}

fn testTuple() {

    assert((1,2) == (1,2))
    assert((1,2,3) == (1,2,3))
    assert((1,2,3) != (1,2,4))
    assert((1,2,3) != (1,2))

    const x = (1, 2)
    const y = (3, 4, 5)

    assert(x == x)
    assert(y == y)
    assert(x != y)
    assert(y != x)
    assert(x != 'z')
    assert('z' != y)

    assert(frozen(x))
    assert(x == freeze(x))
    assert(frozen(x))

    fail(|| => iter(x), "TypeMismatch: Type Tuple has no iter()")
    assert(len(x) == 2)
    assert(len(y) == 3)

    assert('(1, 2)' == str(x))
    assert('(3, 4, 5)' == str(y))

    assert('Tuple' == type(x))

    assert(set { } == fields(x))

    assert(!hasField(x, 'bogus'))
    fail(|| => getField(x, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => setField(x, 'bogus', null), "TypeMismatch: Expected Struct, not Tuple")
    fail(|| => x.bogus = 1, "TypeMismatch: Expected Struct, not Tuple")

    //-----------------------------------------------

    assert([1, 2] == [x[0], x[1]])
}

fn testChan() {

    const p = chan()
    const q = chan(1)

    assert(p == p)
    assert(q == q)
    assert(p != q)
    assert(q != p)
    assert(p != 'z')
    assert('z' != q)

    assert(frozen(p))
    assert(p == freeze(p))
    assert(frozen(p))

    fail(|| => iter(p), "TypeMismatch: Type Chan has no iter()")
    fail(|| => len(p), "TypeMismatch: Type Chan has no len()")

    assert(str(p).hasPrefix('chan<'))
    assert('Chan' == type(p))

    assert(set { 
        'send', 
        'recv' 
    } == fields(p))
    for f in fields(p) {
        assert(hasField(p, f))
    }
    assert(p.send == getField(p, 'send'))
    assert(p.recv == getField(p, 'recv'))

    //assert(!hasField(p, 'bogus'))
    //fail(|| => getField(p, 'bogus'), "NoSuchField: Field 'bogus' not found")
    //fail(|| => setField(p, 'bogus', null), "TypeMismatch: Expected Struct, not Chan")
    //fail(|| => p.bogus = 1, "TypeMismatch: Expected Struct, not Chan")

//    //-------------------------------------------------
//
//    fn sum(a, c) {
//        println(['sum aaa ', a])
//        const total = 0
//        for v in a {
//            total += v
//        }
//        println(['sum bbb ', total])
//        c.send(total)
//    }
//
//    const a = [7, 2, 8, -9, 4, 0]
//    const n = len(a) / 2
//    println([n, a[:n], a[n:], a])
//    const c = chan()
//
//    go sum(a[:n], c)
//    go sum(a[n:], c)
//    const x = c.recv()
//    const y = c.recv()
//    println([x, y])
//    //assert([x, y] == [-5, 17])
//
//    //const ch = chan(2)
//    //ch.send(1)
//    //ch.send(2)
//    //assert([ch.recv(), ch.recv()] == [1, 2])
}

fn testArity() {

    fail(|| => arity(0), 'TypeMismatch: Expected Func, not Int')

    assert(arity(println) == struct { kind: "Variadic", required: 0 })
    assert(arity(len)     == struct { kind: "Fixed",    required: 1 })
    assert(arity(range)   == struct { kind: "Multiple", required: 2, optional: 1 })

    const v = []
    const d = 
        dict{}.addAll(
            [].addAll(fields(v))
                .map(|n| => (n, arity(getField(v, n)))))

    //// TODO
    //const v = []
    //const s = stream(fields(v))
    //    .map(|n| => struct { name: n, field: getField(v, n) })
    //    .map(|s| => (s.name, arity(s.field)))
    //const d = dict{}.addAll(s.toIter())  // option 1
    //const e = s.toDict()                 // option 2

    assert(d ==
        dict { 
            "add":      struct { kind: "Fixed", required: 1 }, 
            "addAll":   struct { kind: "Fixed", required: 1 }, 
            "clear":    struct { kind: "Fixed", required: 0 }, 
            "contains": struct { kind: "Fixed", required: 1 }, 
            "filter":   struct { kind: "Fixed", required: 1 }, 
            "indexOf":  struct { kind: "Fixed", required: 1 }, 
            "isEmpty":  struct { kind: "Fixed", required: 0 }, 
            "map":      struct { kind: "Fixed", required: 1 }, 
            "reduce":   struct { kind: "Fixed", required: 2 }, 
            "remove":   struct { kind: "Fixed", required: 1 },
            "join":     struct { kind: "Multiple", required: 0, optional: 1 } 
        })
}

fn testVariadic() {

    const f = fn(v...) {
        return v
    }

    const g = fn(a, v...) {
        return (a, v)
    }

    const h = fn(a, b, v...) {
        return (a, b, v)
    }

    assert(f()           == [ ])
    assert(f(0)          == [ 0 ])
    assert(f(0, 1)       == [ 0, 1 ])
    assert(f(0, 1, 2)    == [ 0, 1, 2 ])
    assert(f(0, 1, 2, 3) == [ 0, 1, 2, 3 ])

    fail(|| => g(), 'ArityMismatch: Expected at least 1 params, got 0')
    assert(g(0)          == (0, [ ]))
    assert(g(0, 1)       == (0, [ 1 ]))
    assert(g(0, 1, 2)    == (0, [ 1, 2 ]))
    assert(g(0, 1, 2, 3) == (0, [ 1, 2, 3 ]))

    fail(|| => h(),  'ArityMismatch: Expected at least 2 params, got 0')
    fail(|| => h(0), 'ArityMismatch: Expected at least 2 params, got 1')
    assert(h(0, 1)       == (0, 1, [ ]))
    assert(h(0, 1, 2)    == (0, 1, [ 2 ]))
    assert(h(0, 1, 2, 3) == (0, 1, [ 2, 3 ]))

    assert([f, g, h].map(arity) ==
        [ struct { kind: "Variadic", required: 0 }, 
          struct { kind: "Variadic", required: 1 }, 
          struct { kind: "Variadic", required: 2 } ])
}

fn testMultiple() {

    const f = fn(a := 1, b := 2, c := 3) {
        return (a, b, c)
    }

    const g = fn(a, b := 2, c := 3) {
        return (a, b, c)
    }

    const h = fn(a, b, c := 3) {
        return (a, b, c)
    }

    assert(f()              == (1, 2, 3))
    assert(f('x')           == ('x', 2, 3))
    assert(f('x', 'y')      == ('x', 'y', 3))
    assert(f('x', 'y', 'z') == ('x', 'y', 'z'))
    fail(|| => f('x', 'y', 'z', 0), 'ArityMismatch: Expected at most 3 params, got 4')

    fail(|| => g(), 'ArityMismatch: Expected at least 1 params, got 0')
    assert(g('x')           == ('x', 2, 3))
    assert(g('x', 'y')      == ('x', 'y', 3))
    assert(g('x', 'y', 'z') == ('x', 'y', 'z'))
    fail(|| => g('x', 'y', 'z', 0), 'ArityMismatch: Expected at most 3 params, got 4')

    fail(|| => h(),    'ArityMismatch: Expected at least 2 params, got 0')
    fail(|| => h('x'), 'ArityMismatch: Expected at least 2 params, got 1')
    assert(h('x', 'y')      ==  ('x', 'y', 3))
    assert(h('x', 'y', 'z') ==  ('x', 'y', 'z'))
    fail(|| => h('x', 'y', 'z', 0), 'ArityMismatch: Expected at most 3 params, got 4')
}

fn testRange() {

    assert(range(0, 0) == range(0, 0))
    assert(range(0, 0) != range(0, 1))

    const x = range(0, 0)
    const y = range(2, 3)

    assert(x == x)
    assert(y == y)
    assert(x != y)
    assert(y != x)
    assert(x != 'z')
    assert('z' != y)

    assert(frozen(x))
    assert(x == freeze(x))
    assert(frozen(x))

    assert(iter(x) != null)
    assert(len(x) == 0)
    assert(len(y) == 1)

    assert("range<0, 0, 1>" == str(x))
    assert("range<2, 3, 1>" == str(y))

    assert('Range' == type(x))

    const rng = range(0, 10)
    assert(set { 'to', 'count', 'step', 'from' } == fields(rng))
    for f in fields(rng) {
        assert(hasField(rng, f))
    }
    assert(rng.to == getField(rng, 'to'))
    assert(rng.count == getField(rng, 'count'))
    assert(rng.step == getField(rng, 'step'))
    assert(rng.from == getField(rng, 'from'))

    assert(!hasField(rng, 'bogus'))
    fail(|| => getField(rng, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => setField(rng, 'bogus', null), "TypeMismatch: Expected Struct, not Range")
    fail(|| => rng.bogus = 1, "TypeMismatch: Expected Struct, not Range")

    //-----------------------------------------

    fail(|| => iter(range(0,0)).get(), 'NoSuchElement')

    const a = range(0, 5)
    const b = range(0, 5, 2)
    const c = range(2, 14, 3)
    const d = range(-1, -8, -3)
    const e = range(2, 2)
    const f = range(-1, -1, -1)
    const g = range(2, 1, 1)
    const h = range(1, 2, -1)

    assert(listify(a) == [ 0, 1, 2, 3, 4 ])
    assert(listify(b) == [ 0, 2, 4 ])
    assert(listify(c) == [ 2, 5, 8, 11 ])
    assert(listify(d) == [ -1, -4, -7 ])
    assert(listify(e) == [])
    assert(listify(f) == [])
    assert(listify(g) == [])
    assert(listify(h) == [])

    assert(iterate(a) == [ 0, 1, 2, 3, 4 ])
    assert(iterate(b) == [ 0, 2, 4 ])
    assert(iterate(c) == [ 2, 5, 8, 11 ])
    assert(iterate(d) == [ -1, -4, -7 ])
    assert(iterate(e) == [])
    assert(iterate(f) == [])
    assert(iterate(g) == [])
    assert(iterate(h) == [])

    assert([a.from(), a.to(), a.step(), a.count()] == [0, 5, 1, 5])
    assert([b.from(), b.to(), b.step(), b.count()] == [0, 5, 2, 3])
    assert([c.from(), c.to(), c.step(), c.count()] == [2, 14, 3, 4])
    assert([d.from(), d.to(), d.step(), d.count()] == [-1, -8, -3, 3])
    assert([e.from(), e.to(), e.step(), e.count()] == [2, 2, 1, 0])
    assert([f.from(), f.to(), f.step(), f.count()] == [-1, -1, -1, 0])
    assert([g.from(), g.to(), g.step(), g.count()] == [2, 1, 1, 0])
    assert([h.from(), h.to(), h.step(), h.count()] == [1, 2, -1, 0])

    let i = 0
    const ls = [2, 5, 8, 11]
    while i < c.count() {
        assert(c[i] == ls[i])
        i++
    } 
    assert(i == 4)

    fail(|| => range(0, 0, 0), "InvalidArgument: step cannot be 0")
}

fn testStruct() {

    fail(|| => len(struct{}), 'TypeMismatch: Type Struct has no len()')
    fail(|| => iter(struct{}), 'TypeMismatch: Type Struct has no iter()')

    assert("struct { }" == str(struct {}))
    assert("struct { a: 1 }" == str(struct {a: 1}))

    //-----------------------------------------

    const funcs = [
        fn () {
            assert(struct {} == struct{})
            assert(struct {a: 1} == struct{a: 1})
            assert(struct {a: 1, b: 2} == struct{a: 1, b: 2})
            assert(struct {a: 1, b: 2, c: 3} == struct{a: 1, b: 2, c: 3})

            assert(struct {a: 1, b: 2, c: 3} != struct{a: 1, b: 2, d: 4})
            assert(struct {a: 1, b: 2, c: 3} != struct{a: 1, b: 2})
            assert(struct {a: 1, b: 2, c: 3} != struct{a: 1})
            assert(struct {a: 1, b: 2, c: 3} != struct{})

            const x = struct{}
            const y = struct{a: 1}

            assert(x == x)
            assert(y == y)
            assert(x != y)
            assert(y != x)
            assert(x != 'z')
            assert('z' != y)

            assert(!frozen(y))
            assert(y == freeze(y))
            assert(frozen(y))
            fail(|| => y.a = 2, "ImmutableValue")

            assert('Struct' == type(x))

            assert(!hasField(x, 'bogus'))
            fail(|| => getField(x, 'bogus'), "NoSuchField: Field 'bogus' not found")
            fail(|| => setField(x, 'bogus', null), "NoSuchField: Field 'bogus' not found")
            fail(|| => x.bogus = 1, "NoSuchField: Field 'bogus' not found")
        },
        fn () {
            const w = struct {}
            const x = struct { a: 0 }
            const y = struct { a: 1, b: 2 }
            const z = struct { a: 3, b: 4, c: struct { d: 5 } }

            assert([0] == [x.a])
            assert([1, 2] == [y.a, y.b])
            assert([3, 4, 5] == [z.a, z.b, z.c.d])

            for s in [w, x, y, z] {
                fail(|| => s.bogus, "NoSuchField: Field 'bogus' not found")
            }
        },
        fn () {
            const x = struct { a: 5 }
            const y = x.a
            x.a = 6
            assert([5, 6] == [y, x.a])
        },
        fn () {
            const a = struct {
                x: 8,
                y: 5,
                plus:  fn() { return this.x + this.y; },
                minus: fn() { return this.x - this.y; }
            }
            const b = a.plus()
            const c = a.minus()
            assert([13, 3] == [b, c])
        },
        fn () {
            let a = null
            a = struct { x: 8 }.x = 5
            assert(5 == a)
        },
        fn () {
            const s = struct { 
                a: prop { || => 1 } 
            }
            assert(1 == s.a)
            fail(|| => s.a = 2, "ReadonlyField: Field 'a' is readonly")
        },
        fn () {
            let x = 2
            const s = struct { 
                a: prop { || => 1 } ,
                b: prop { || => x, |v| => x = v },
                c: || => this.a + this.b
            }
            fail(|| => s.a = 2, "ReadonlyField: Field 'a' is readonly")

            assert([s.a, s.b, x, s.c()] == [1, 2, 2, 3])

            s.b = 3
            assert([s.a, s.b, x, s.c()] == [1, 3, 3, 4])

            x = 4
            assert([s.a, s.b, x, s.c()] == [1, 4, 4, 5])
        },
        fn () {
            fn newRectangle(w, h) {
                return struct {
                    width:  prop { || => w, |val| => w = val },
                    height: prop { || => h, |val| => h = val },
                    area:   || => w * h
                }
            }

            fn newBox(rect, d) {
                return merge(
                    rect, 
                    struct {
                        depth:  prop { || => d, |val| => d = val },
                        volume: || => rect.area() * d
                    })
            }

            const r = newRectangle(2, 3)
            const b = newBox(r, 4)

            assert(fields(r) == set { 'width', 'height', 'area' })
            assert(fields(b) == set { 'width', 'depth', 'height', 'volume', 'area' })

            assert([b.width, b.height, b.depth, b.area(), b.volume()] == [2, 3, 4, 6, 24])
            r.width = 5
            assert([b.width, b.height, b.depth, b.area(), b.volume()] == [5, 3, 4, 15, 60])
        }
    ]
    for f in funcs { f(); }
}

fn testMerge() {

    fail(|| => merge(), 'ArityMismatch: Expected at least 2 params, got 0')
    fail(|| => merge(true), 'ArityMismatch: Expected at least 2 params, got 1')
    fail(|| => merge(struct{}, false), 'TypeMismatch: Expected Struct, not Bool')
    fail(|| => merge(struct{}, struct{}, struct{}, []), 'TypeMismatch: Expected Struct, not List')

    const a = struct { x: 1, y: 2}
    const b = merge(a, struct { y: 3, z: 4})
    assert(b.x == 1)
    assert(b.y == 3)
    assert(b.z == 4)
    a.x = 5
    a.y = 6
    assert(b.x == 5)
    assert(b.y == 3)
    assert(b.z == 4)
    const c = merge(b, struct { w: 10})
    assert(c.x == 5)
    assert(c.y == 3)
    assert(c.z == 4)
    assert(c.w == 10)
    a.x = 7
    b.z = 11
    assert(c.x == 7)
    assert(c.y == 3)
    assert(c.z == 11)
    assert(c.w == 10)

    const z = merge(struct { a: 1}, struct { b: 2}, struct { c: 3}, struct { d: 4})
    assert(struct { a: 1, b: 2, c: 3, d: 4} == z)

    const f = freeze(struct { x: 1, y: 2})
    const g = freeze(struct { x: 3, z: 4})
    const h = merge(f, g)
    assert(struct { x: 3, y: 2, z: 4} == h)

    const ls = [a, b, c, f, g, h].map(frozen)
    assert([ false, false, false, true, true, true ] == ls)

    fail(|| => merge(a, b, f), 'InvalidArgument: Cannot merge structs unless they are all frozen, or all unfrozen')
    fail(|| => merge(a, f, b), 'InvalidArgument: Cannot merge structs unless they are all frozen, or all unfrozen')
    fail(|| => merge(f, a, b), 'InvalidArgument: Cannot merge structs unless they are all frozen, or all unfrozen')
    fail(|| => merge(f, g, b), 'InvalidArgument: Cannot merge structs unless they are all frozen, or all unfrozen')
}

fn testInvokeField() {
    const s = 'abc'
    const c = s.contains
    const x = c('b')
    const y = s.contains('z')

    const ls = [1]
    const p = iter(ls).next()

    assert([true, false, true] == [x, y, p])
}

fn main(args) {

    assert(42 == zork.quux)

    assert(assert == assert);
    assert(print == print);
    assert(println == println);
    assert(assert != print);
    assert(assert != println);
    assert(print != println);

    testExpressions() 
    testAssignment()
    testFlowControl()
    testInvokeField()
//    testTry() TODO try-catch-finally appears to be broken

    testFunc()
    testCapture()
    testNamedFunc()
    testLambda()
    testArity() 
    testVariadic() 
    testMultiple() 

    testNull()
    testBool()
    testStr()
    testInt()
    testFloat()
    testList()
    testRange()
    testTuple()
    testDict() 
    testSet() 
    testStruct() 
    testMerge() 
    testChan() // TODO this appears to be broken
}


