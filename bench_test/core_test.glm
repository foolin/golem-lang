// Copyright 2018 The Golem Language Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

import golem
import zork

fn fail(func, err) {
    try {
        func()
        assert(false)
    } catch e {
        //println(e.error)
        assert(err == e.error)
    }
}

fn listify(ibl) {
    const ls = []
    for n in ibl {
        ls.add(n)
    }
    return ls
}

fn iterate(ibl) {
    const ls = []
    const itr = iter(ibl)
    fail(|| => itr.get(), 'NoSuchElement')
    while itr.next() {
        ls.add(itr.get())
    }
    fail(|| => itr.get(), 'NoSuchElement')
    return ls
}

fn testExpressions() {

    assert(42 == zork.quux)

    assert(assert == assert);
    assert(print == print);
    assert(println == println);
    assert(assert != print);
    assert(assert != println);
    assert(print != println);

    assert((2 + 3) * -4 / 10 == -2)
    assert((2*2*2*2 + 2*3*(8 - 1) + 2) / (17 - 2*2*2 - -1) == 6)

    assert(true + 'a' == 'truea')
    assert('a' + true == 'atrue')
    assert('a' + null == 'anull')
    assert(null + 'a' == 'nulla')

    assert("\n\"abc\"\ndef" == `
"abc"
def`)

    fail(|| => true + null, 'TypeMismatch: Expected Int or Float, not Bool')
    fail(|| => 1 + null, 'TypeMismatch: Expected Int or Float, not Null')
    fail(|| => null + 1, 'TypeMismatch: Expected Int or Float, not Null')

    assert((true == 'a') == false)
    assert((3 * 7 + 4 == 5 * 5) == true)
    assert((1 != 1) == false)
    assert((1 != 2) == true)

    assert(!false == true)
    assert(!true == false)
    fail(|| => !null, 'TypeMismatch: Expected Bool, not Null')
    fail(|| => !'a', 'TypeMismatch: Expected Bool, not Str')
    fail(|| => !1, 'TypeMismatch: Expected Bool, not Int')
    fail(|| => !1.0, 'TypeMismatch: Expected Bool, not Float')

    assert(1 < 2 == true)
    assert(1 <= 2 == true)
    assert(1 > 2 == false)
    assert(1 >= 2 == false)

    assert(2 < 2 == false)
    assert(2 <= 2 == true)
    assert(2 > 2 == false)
    assert(2 >= 2 == true)

    assert(1 <=> 2 == -1)
    assert(2 <=> 2 == 0)
    assert(2 <=> 1 == 1)

    assert((true  && true) == true)
    assert((true  && false) == false)
    assert((false && true) == false)
    assert((false && 12) == false)
    fail(|| => 12 && false, 'TypeMismatch: Expected Bool, not Int')

    assert(true  || (true == true))
    assert(true  || (false == true))
    assert(false || (true == true))
    assert(false || (false == false))
    assert(true  || (12 == true))
    fail(|| => 12  || true, 'TypeMismatch: Expected Bool, not Int')

    assert(~0 == -1)
    assert(8 % 2 == 0)
    assert(8 & 2 == 0)
    assert(8 | 2 == 10)
    assert(8 ^ 2 == 10)
    assert(8 << 2 == 32)
    assert(8 >> 2 == 2)

    assert([-3,1,1,-1,-3,-7] == [~2, ~-2, 7 % -3, -11 % 2, -4 | -3, -17 ^ 22])

    fail(|| => 1 << -1, 'InvalidArgument: Shift count cannot be less than zero')
    fail(|| => 1 >> -1, 'InvalidArgument: Shift count cannot be less than zero')

    assert([true][0] == true)
    assert('abc'[1] == 'b')
    assert('abc'[-1] == 'c')
    fail(|| => 'abc'[3], 'IndexOutOfBounds: 3')
    fail(|| => [true][2], 'IndexOutOfBounds: 2')
    fail(|| => (1,2)[3], 'IndexOutOfBounds: 3')
    fail(|| => range(0, 2)[2], 'IndexOutOfBounds: 2')

    assert('abc'[1:] == 'bc')
    assert('abc'[:1] == 'a')
    assert('abcd'[1:3] == 'bc')
    assert('abcd'[1:1] == '')

    assert([6,7,8][1:] == [7,8])
    assert([6,7,8][:1] == [6])
    assert([6,7,8,9][1:3] == [7,8])
    assert([6,7,8,9][1:1] == [])

    fail(|| => len(true), 'TypeMismatch: Type Bool has no len()')
    fail(|| => true[0], 'TypeMismatch: Type Bool cannot be indexed')
    fail(|| => true[0] = 1, 'TypeMismatch: Type Bool cannot be indexed')
    fail(|| => true[0:1], 'TypeMismatch: Type Bool cannot be sliced')
    fail(|| => true[:1], 'TypeMismatch: Type Bool cannot be sliced')
    fail(|| => true[0:], 'TypeMismatch: Type Bool cannot be sliced')
    fail(|| => set {} < 3, 'TypeMismatch: Types Set and Int cannot be compared')
    fail(|| => 3 > set {}, 'TypeMismatch: Types Int and Set cannot be compared')
}

fn testInt() {
    assert(1 == 1)
    assert(2 == 2)
    assert(1 != 2)
    assert(2 != 1)
    assert(1 != 'z')
    assert('z' != 2)

    assert(frozen(1))
    assert(1 == freeze(1))
    assert(frozen(1))

    fail(|| => iter(1), "TypeMismatch: Type Int has no iter()")
    fail(|| => len(1), "TypeMismatch: Type Int has no len()")

    assert('1' == str(1))
    assert('Int' == type(1))

    assert(set {} == fields(1))
    assert(!has(1, 'bogus'))
    fail(|| => 1 .bogus, "NoSuchField: Field 'bogus' not found") // Note that '1.bogus' fails to parse
    fail(|| => golem.getField(1, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.setField(1, 'bogus', null), "TypeMismatch: Expected Struct, not Int")
    fail(|| => 1 .bogus = 'z', "TypeMismatch: Expected Struct, not Int")
}

fn testFloat() {
    assert(1.1 == 1.1)
    assert(2.2 == 2.2)
    assert(1.1 != 2.2)
    assert(2.2 != 1.1)
    assert(1.1 != 'z')
    assert('z' != 2.2)

    assert(frozen(1.1))
    assert(1.1 == freeze(1.1))
    assert(frozen(1.1))

    fail(|| => iter(1.1), "TypeMismatch: Type Float has no iter()")
    fail(|| => len(1.1), "TypeMismatch: Type Float has no len()")

    assert('1.1' == str(1.1))
    assert('Float' == type(1.1))

    assert(set {} == fields(1.1))
    assert(!has(1.1, 'bogus'))
    fail(|| => 1.1 .bogus, "NoSuchField: Field 'bogus' not found") // Note that '1.1.bogus' fails to parse
    fail(|| => golem.getField(1.1, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.setField(1.1, 'bogus', null), "TypeMismatch: Expected Struct, not Float")
    fail(|| => 1.1 .bogus = 'z', "TypeMismatch: Expected Struct, not Float")

    assert(1.0 + 2.0 == 3.0)
    assert(1.0 - 2.0 == -1.0)
    assert(3.0 * 2.0 == 6.0)
    assert(3.0 / 2.0 == 1.5)
    fail(|| => 3.0 / 0.0, 'DivideByZero')
}

fn testAssignment() {
    const funcs = [
        fn () {
            let a = 1
            const b = 2
            a = a + b
            assert([3, 2] == [a, b])
        },
        fn () {
            let a = 1
            a = a + 41
            const b = a / 6
            let c = b + 3
            c = (c + a)/13
            assert([42, 7, 4] == [a, b, c])
        },
        fn () {
            let a = 1
            let b = a += 3
            let c = ~0
            c -= -2
            c <<= 4
            b *= 2
            assert([4, 8, 16] == [a, b, c])
        },
        fn () {
            let a = 1
            let b = 2
            a = b = 11
            b = a %= 4
            assert([3, 3] == [a, b])
        },
        fn () {
            let a = 10
            let b = 20
            const c = a++
            const d = b--
            assert([11, 19, 10, 20] == [a, b, c, d])

            fail(fn() {
                    let e = 'abc'
                    e++
                }, "TypeMismatch: Expected Int or Float, not Str")
        },
        fn () {
            const a = [10]
            const b = [20]
            const c = a[0]++
            const d = b[0]--
            assert([[11], [19], 10, 20] == [a, b, c, d])

            fail(fn() {
                    const e = ['abc']
                    e[0]++
                }, "TypeMismatch: Expected Int or Float, not Str")
        },
        fn () {
            const a = struct { x: 10 }
            const b = struct { y: 20 }
            const c = a.x++
            const d = b.y--
            assert([struct { x: 11 }, struct { y: 19 }, 10, 20] == [a, b, c, d])

            fail(fn() {
                    const e = struct { x: 'abc' }
                    e.x++
                }, "TypeMismatch: Expected Int or Float, not Str")
        }
    ]
    for f in funcs { f(); }
}

fn testFlowControl() {
    const funcs = [
        fn () {
            let a = 1; if (true) { a = 2; }
            assert(a == 2)
        },
        fn () {
            let a = 1; if (false) { a = 2; }
            assert(a == 1)
        },
        fn () {
            let a = 1; if (1 == 1) { a = 2; } else { a = 3; }; const b = 4;
            assert(a == 2 && b == 4)
        },
        fn () {
            let a = 1; if (1 == 2) { a = 2; } else { a = 3; }; const b = 4;
            assert(a == 3 && b == 4)
        },
        fn () {
            const a = true ? 3 : 4;
            const b = false ? 5 : 6;
            assert(a == 3 && b == 6)
        },
        fn () {
            let a = 1
            while (a < 3) {
                a = a + 1
            }
            assert(a == 3)
        },
        fn () {
            let a = 1
            while (a < 11) {
                if (a == 4) { a = a + 2; break; }
                a = a + 1
            }
            assert(a == 6)
        },
        fn () {
            let a = 1
            let b = 0
            while (a < 11) {
                a = a + 1
                if (a > 5) { continue; }
                b = b + 1
            }
            assert(a == 11 && b == 4)
        },
        fn () {
            let s = ''
            for i in range(0, 4) {
                switch {
                case i == 0:
                    s += 'a'

                case i == 1, i == 2:
                    s += 'b'

                default:
                    s += 'c'
                }
            }
            assert(s == 'abbc')
        },
        fn () {
            let s = ''
            for i in range(0, 4) {
                switch {
                case i == 0, i == 1:
                    s += 'a'

                case i == 2:
                    s += 'b'
                }
            }
            assert(s == 'aab')
        },
        fn () {
            let s = ''
            for i in range(0, 4) {
                switch i {
                case 0, 1:
                    s += 'a'

                case 2:
                    s += 'b'
                }
            }
            assert(s == 'aab')
        }
    ]
    for f in funcs { f(); }
}

fn testFunc() {

    const f = || => null
    const g = || => null

    assert(f == f)
    assert(g == g)
    assert(f != g)
    assert(g != f)
    assert(f != 'z')
    assert('z' != g)

    assert(frozen(f))
    assert(f == freeze(f))
    assert(frozen(f))

    fail(|| => iter(f), "TypeMismatch: Type Func has no iter()")
    fail(|| => len(f), "TypeMismatch: Type Func has no len()")

    assert(str(f).hasPrefix('func<'))
    assert('Func' == type(f))

    assert(set {} == fields(f))
    assert(!has(f, 'bogus'))
    fail(|| => f.bogus, "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.getField(f, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.setField(f, 'bogus', null), "TypeMismatch: Expected Struct, not Func")
    fail(|| => f.bogus = 'z', "TypeMismatch: Expected Struct, not Func")

    //------------------------------------------

    let a = fn(x) { x; }
    let b = a(1)
    assert(b == 1)

    a = fn() { }
    b = fn(x) { x; }
    const c = fn(x, y) { const z = 4; x * y * z; }
    const d = a()
    const e = b(1)
    const h = c(b(2), 3)
    assert([null, 1, 24] == [d, e, h])

    const fibonacciGenerator = fn() {
        let x = 1
        let y = 1
        return fn() {
            const z = x
            x = y
            y = x + z
            return z
        }
    }
    const fg = fibonacciGenerator()
    const list = []
    for i in range(0, 10) {
        list.add(fg())
    }
    assert([1, 1, 2, 3, 5, 8, 13, 21, 34, 55] == list)

    const foo = fn(n) {
        const bar = fn(x) {
            return x * (x - 1)
        }
        return bar(n) + bar(n-1)
    }
    assert(32 == foo(5))

    fail(|| => 1/0, 'DivideByZero')
    fail(|| => true(), 'TypeMismatch: Expected Func, not Bool')
}

fn testCapture() {

    const accumGen = fn(n) {
        return fn(i) {
            n = n + i
            return n
        }
    }
    const a = accumGen(3)
    const x = a(2)
    const y = a(7)
    assert([5, 12] == [x, y])

    //---------------------

    let z = 2
    const acc2 = fn(n) {
        return fn(i) {
            n = n + i
            n = n + z
            return n
        }
    }
    const b = acc2(3)
    const i = b(2)
    z = 0
    const j = b(1)
    assert([0, 7, 8] == [z, i, j])

    const m = 123
    const n = 456

    fn foo() {
        assert(n == 456)
        assert(m == 123)
    }
    foo()

    //---------------------

    const cap = 1
    const f1 = || => cap
    const f2 = || => cap
    assert([1, 1] == [f1(), f2()])
}

fn testNamedFunc() {
    fn a() {
        return b()
    }
    fn b() {
        return 42
    }
    assert(a() == 42)
}

fn testLambda() {
    const z = 5
    const a = || => 3
    const b = |x| => x * x
    const c = |x, y| => (x + y)*z
    assert(a() == 3)
    assert(b(2) == 4)
    assert(c(1, 2) == 15)
}

fn testNull() {

    assert(null == null)
    assert(null != 1)
    assert(1 != null)

    fail(|| => freeze(null), "NullValue")
    fail(|| => frozen(null), "NullValue")
    fail(|| => iter(null), "NullValue")
    fail(|| => len(null), "NullValue")
    fail(|| => range(null, null), "NullValue")
    assert('null' == str(null)) // this is convenient
    assert('Null' == type(null)) // this is convenient

    fail(|| => fields(null), "NullValue")
    fail(|| => has(null, 'bogus'), "NullValue")

    fail(|| => golem.getField(null, 'bogus'), "NullValue")
    fail(|| => null.bogus, "NullValue")
    fail(|| => null.bogus(), "NullValue")
    fail(|| => golem.setField(null, 'bogus', null), "NullValue")
    fail(|| => null.bogus = 1, "NullValue")
}

fn testBool() {

    assert(true == true)
    assert(false == false)
    assert(true != false)
    assert(false != true)
    assert(true != 1)
    assert(1 != false)

    assert(frozen(true))
    assert(frozen(false))
    assert(true == freeze(true))
    assert(false == freeze(false))
    assert(frozen(true))
    assert(frozen(false))

    fail(|| => iter(true), "TypeMismatch: Type Bool has no iter()")
    fail(|| => iter(false), "TypeMismatch: Type Bool has no iter()")
    fail(|| => len(true), "TypeMismatch: Type Bool has no len()")
    fail(|| => len(false), "TypeMismatch: Type Bool has no len()")

    fail(|| => range(true, 1), "TypeMismatch: Expected Int, not Bool")
    fail(|| => range(false, 1), "TypeMismatch: Expected Int, not Bool")
    fail(|| => range(1, true), "TypeMismatch: Expected Int, not Bool")
    fail(|| => range(1, false), "TypeMismatch: Expected Int, not Bool")

    assert('true' == str(true))
    assert('false' == str(false))

    assert('Bool' == type(true))
    assert('Bool' == type(false))

    assert(set{} == fields(true))
    assert(set{} == fields(false))

    assert(false == has(true, 'bogus'))
    assert(false == has(false, 'bogus'))

    fail(|| => golem.getField(true,  'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.getField(false, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => true.bogus, "NoSuchField: Field 'bogus' not found")
    fail(|| => false.bogus, "NoSuchField: Field 'bogus' not found")
    fail(|| => true.bogus(), "NoSuchField: Field 'bogus' not found")
    fail(|| => false.bogus(), "NoSuchField: Field 'bogus' not found")

    fail(|| => golem.setField(true, 'bogus', null), "TypeMismatch: Expected Struct, not Bool")
    fail(|| => golem.setField(false, 'bogus', null), "TypeMismatch: Expected Struct, not Bool")
    fail(|| => true.bogus = 1,  "TypeMismatch: Expected Struct, not Bool")
    fail(|| => false.bogus = 1, "TypeMismatch: Expected Struct, not Bool")
}

fn testStr() {

    assert('a' == 'a')
    assert('b' == 'b')
    assert('a' != 'b')
    assert('b' != 'a')
    assert('a' != 1)
    assert(1 != 'b')

    assert(frozen('a'))
    assert('a' == freeze('a'))
    assert(frozen('a'))

    assert(iter('a') != null)
    assert(1 == len('a'))

    fail(|| => range('a', 1), "TypeMismatch: Expected Int, not Str")
    fail(|| => range(1, 'a'), "TypeMismatch: Expected Int, not Str")

    assert('a' == str('a'))
    assert('Str' == type('a'))

    let s = 'a'
    assert(set { 
        'contains', 'index', 'lastIndex', 
        'hasPrefix', 'hasSuffix',
        'replace', 'split', 'trim', 'toChars', 'map'
    } == fields(s))
    for f in fields(s) {
        assert(has(s, f))
    }
    assert(s.contains == golem.getField(s, 'contains'))
    assert(s.index == golem.getField(s, 'index'))
    assert(s.lastIndex == golem.getField(s, 'lastIndex'))
    assert(s.hasPrefix == golem.getField(s, 'hasPrefix'))
    assert(s.hasSuffix == golem.getField(s, 'hasSuffix'))
    assert(s.replace == golem.getField(s, 'replace'))
    assert(s.split == golem.getField(s, 'split'))
    assert(s.trim == golem.getField(s, 'trim'))
    assert(s.toChars == golem.getField(s, 'toChars'))
    assert(s.map == golem.getField(s, 'map'))

    assert(!has(s, 'bogus'))
    fail(|| => golem.getField(s, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.setField(s, 'bogus', null), "TypeMismatch: Expected Struct, not Str")
    fail(|| => s.bogus = 1, "TypeMismatch: Expected Struct, not Str")

    //---------------------------------------------

    s = '34這';
    assert(s[0:1] == '3');
    assert(s[1:3] == '4這');
    assert(s[-2:-1] == '4');
    assert(s[-5:-4] == '');
    assert(s[3:4] == '');
    assert(s[3:1] == '');
    assert(s[1:0] == '');

    s = '\u{1f496}\u{2665}\u{24}'
    assert('💖' == s[0])
    assert('♥'  == s[1])
    assert('$'  == s[2])

    assert(listify(s) == ['💖', '♥', '$'])
    assert(iterate(s) == ['💖', '♥', '$'])
    assert(listify('abc') == ['a', 'b', 'c'])
    assert(iterate('abc') == ['a', 'b', 'c'])
    assert(listify('') == [])
    assert(iterate('') == [])

    // This is some chinese text that we are going to use for testing purposes.
    // 這是我們將用於測試目的的一些中文文本。

    s = "這是我們abc"
    assert(7 == len(s))
    let reverse = ''  
    for c in s {
        reverse = c + reverse
    }
    assert('cba們我是這' == reverse)

    fail(|| => iter('').get(), 'NoSuchElement')
    const count = 0
    const itr = iter(s)
    fail(|| => itr.get(), 'NoSuchElement')
    reverse = ''  
    while itr.next() {
        reverse = itr.get() + reverse
    }
    assert('cba們我是這' == reverse)
    fail(|| => itr.get(), 'NoSuchElement')

    const f = s.contains
    assert(true == f('ab'))
    assert(true == s.contains('這是我'))
    assert(true == s.contains('們ab'))
    assert(false == s.contains('z'))
    assert(true == 'abcde'.contains('cd'))
    assert(true == 'abcde'.contains('d'))
    assert(false == ''.contains('cd'))
    assert(false == ''.contains('d'))
    fail(|| => s.contains(), 'ArityMismatch: Expected 1 parameter, got 0')
    fail(|| => s.contains(1), 'TypeMismatch: Expected Str, not Int')

    assert(0 == s.index('這是我'))
    assert(3 == s.index('們ab'))
    assert(-1 == s.index('z'))
    assert(2 == 'abcde'.index('cd'))
    assert(3 == 'abcde'.index('d'))
    assert(-1 == ''.index('cd'))
    assert(-1 == ''.index('d'))
    fail(|| => s.index(), 'ArityMismatch: Expected 1 parameter, got 0')
    fail(|| => s.index(1), 'TypeMismatch: Expected Str, not Int')

    s = "這是我們a們abc"
    assert(0 == s.lastIndex('這是我'))
    assert(5 == s.lastIndex('們a'))
    assert(-1 == s.lastIndex('z'))
    assert(2 == 'abcde'.lastIndex('cd'))
    assert(5 == 'abcdcde'.lastIndex('d'))
    assert(-1 == ''.lastIndex('cd'))
    assert(-1 == ''.lastIndex('d'))
    fail(|| => s.lastIndex(), 'ArityMismatch: Expected 1 parameter, got 0')
    fail(|| => s.lastIndex(1), 'TypeMismatch: Expected Str, not Int')

    assert(s.hasPrefix('這是我'))
    assert(!s.hasPrefix('bc'))
    assert(!''.hasPrefix('這是我'))
    assert(!''.hasPrefix('bc'))
    fail(|| => s.lastIndex(), 'ArityMismatch: Expected 1 parameter, got 0')
    fail(|| => s.lastIndex(1), 'TypeMismatch: Expected Str, not Int')

    assert(!s.hasSuffix('這是我'))
    assert(s.hasSuffix('bc'))
    assert(!''.hasSuffix('這是我'))
    assert(!''.hasSuffix('bc'))
    fail(|| => s.lastIndex(), 'ArityMismatch: Expected 1 parameter, got 0')

    assert("這是我zzbc" == s.replace('們a', 'z'))
    assert("這是我z們abc" == s.replace('們a', 'z', 1))
    assert('abc' == 'abc'.replace('x', 'y'))
    fail(|| => s.replace(), 'ArityMismatch: Expected at least 2 parameters, got 0')

    assert(['a', 'b', 'c'] == 'a,b,c'.split(','))
    assert(['abc'] == 'abc'.split(','))
    assert([''] == ''.split(','))
    fail(|| => s.split(), 'ArityMismatch: Expected 1 parameter, got 0')

    let delims = set{}.addAll('()[]'.toChars())
    s = 'a]b)cdef(g[h]'.map(|r| => delims.contains(r) ? ' ' : r)

    assert(['a', 'b', 'c'] == 'abc'.toChars())
    assert(set{'[', ']', '(', ')'} == delims)
    assert('a b cdef g h ' == s)

    fail(|| => s.map(|r| => 0), 'TypeMismatch: map function must return Str, not Int')

    fail(|| => s.map(|| => null),      "ArityMismatch: map function must have 1 parameter")
    fail(|| => s.map(|a,b| => null),   "ArityMismatch: map function must have 1 parameter")
    fail(|| => s.map(fn(a...) {}),     "ArityMismatch: map function must have 1 parameter")
    fail(|| => s.map(fn(a, b = 2) {}), "ArityMismatch: map function must have 1 parameter")

    s = 'abc'
    const c = s.contains
    const x = c('b')
    const y = s.contains('z')
    const ls = [1]
    const p = iter(ls).next()
    assert([true, false, true] == [x, y, p])

    s = '\t\nabc \n\t'
    assert('abc' == s.trim('\n\t '))
}

fn testList() {

    assert([] == [])
    assert([1] == [1])
    assert([1,2] == [1,2])
    assert([1,2,3] == [1,2,3])
    assert([1,2,3] != [1,2,4])
    assert([1,2,3] != [1,2])
    assert([1,2,3] != [1])
    assert([1,2,3] != [])

    const x = []
    const y = [1]

    assert(x == x)
    assert(y == y)
    assert(x != y)
    assert(y != x)
    assert(x != 'z')
    assert('z' != y)

    assert(!frozen(x))
    assert(x == freeze(x))
    assert(frozen(x))
    fail(|| => x.add(1), "ImmutableValue")
    fail(|| => x.addAll(1), "ImmutableValue")
    fail(|| => x.remove(1), "ImmutableValue")
    fail(|| => x.clear(), "ImmutableValue")
    x.isEmpty()
    x.contains(1)
    x.index(1)
    x.map(|e| => e)
    x.reduce(0, |acc, e| => acc + e)
    x.filter(|e| => e)

    assert(iter(x) != null)
    assert(len(x) == 0)
    assert(len(y) == 1)

    assert("[ ]" == str([]))
    assert("[ 1 ]" == str([1]))
    assert("[ 1, 2 ]" == str([1,2]))

    assert('List' == type(x))

    assert(set { 
        'isEmpty', 
        'contains', 
        'index', 
        'join',
        'map',
        'reduce',
        'filter',

        'add', 
        'addAll',
        'clear',
        'remove', 
        'sort' 
    } == fields(x))
    for f in fields(x) {
        assert(has(x, f))
    }
    assert(x.isEmpty == golem.getField(x, 'isEmpty'))
    assert(x.contains == golem.getField(x, 'contains'))
    assert(x.join == golem.getField(x, 'join'))
    assert(x.index == golem.getField(x, 'index'))
    assert(x.map == golem.getField(x, 'map'))
    assert(x.reduce == golem.getField(x, 'reduce'))
    assert(x.filter == golem.getField(x, 'filter'))

    assert(x.add == golem.getField(x, 'add'))
    assert(x.addAll == golem.getField(x, 'addAll'))
    assert(x.clear == golem.getField(x, 'clear'))
    assert(x.remove == golem.getField(x, 'remove'))
    assert(x.sort == golem.getField(x, 'sort'))

    assert(!has(x, 'bogus'))
    fail(|| => golem.getField(x, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.setField(x, 'bogus', null), "TypeMismatch: Expected Struct, not List")
    fail(|| => x.bogus = 1, "TypeMismatch: Expected Struct, not List")

    //-------------------------------------------------

    const funcs = [
        fn () {
            let count = 0
            for n in [1, 2, 3] {
                count += n
            }
            assert(6 == count)
        },
        fn () {
            fail(|| => iter([]).get(), 'NoSuchElement')
            let count = 0
            const itr = iter([1, 2, 3])
            fail(|| => itr.get(), 'NoSuchElement')
            while itr.next() {
                count += itr.get()
            }
            assert(6 == count)
            fail(|| => itr.get(), 'NoSuchElement')
        },
        fn () {
            const a = []
            const b = [true]
            const c = [false,22]
            const d = b[0]
            b[0] = 33
            const e = c[1]++
            assert([[], [ 33 ], [ false, 23 ], true, 22] == [a, b, c, d, e])
        },
        fn () {
            const a = []
            a.add(1)
            assert(a == [1])
            a.add(2).add([3])
            assert(a == [1,2,[3]])
            const b = []
            b.add(null)
            assert(b == [null])
            assert(a.add == a.add)
            assert(b.add == b.add)
            assert(a.add != b.add)

            const f = b.add
            f(5)
            assert(b == [null, 5])

            assert(b.remove(1) == [null])
        },
        fn () {
            const a = []
            a.addAll([1,null]).addAll('bc').addAll([])
            assert(a == [1,null,'b','c'])
        },
        fn () {
            const a = []
            assert(a.isEmpty())
            a.add(1)
            assert(!a.isEmpty())
            a.clear()
            assert(a.isEmpty())
        },
        fn () {
            let a = []
            assert(!a.contains('x'))
            assert(a.index('x') == -1)
            a = ['z', 'x']
            assert(a.contains('x'))
            assert(a.index('x') == 1)
        },
        fn () {
            const a = [1, 2, 3]
        },
        fn () {
            const a = []
            assert(a.join() == '')
            assert(a.join(',') == '')
            a.add(1)
            assert(a.join() == '1')
            assert(a.join(',') == '1')
            a.add(2)
            assert(a.join() == '12')
            assert(a.join(',') == '1,2')
            a.add('abc')
            assert(a.join() == '12abc')
            assert(a.join(',') == '1,2,abc')
        },
        fn () {
            const ls = [1, 2, 3, 4, 5]
            const squares = ls.map(|x| => x * x)
            const addedUp = ls.reduce(0, |acc, x| => acc + x)
            const even = ls.filter(|x| => (x % 2 == 0))

            assert(squares == [1, 4, 9, 16, 25])
            assert(addedUp == 15)
            assert(even == [2, 4])

            ls.remove(2)
            assert(ls == [1, 2, 4, 5])
            assert('null1245' == ls.reduce(null, |acc, x| => str(acc) + x))

            fail(|| => ls.reduce(0, null), 'NullValue')
        },
        fn () {
            let ls = freeze([2, 1, 3])

            assert([ 4, 1, 9 ] == ls.map(|a| => a*a) && [2, 1, 3] == ls)
            fail(|| => ls.map(|| => null),      "ArityMismatch: map function must have 1 parameter")
            fail(|| => ls.map(|a,b| => null),   "ArityMismatch: map function must have 1 parameter")
            fail(|| => ls.map(fn(a...) {}),     "ArityMismatch: map function must have 1 parameter")
            fail(|| => ls.map(fn(a, b = 2) {}), "ArityMismatch: map function must have 1 parameter")

            assert(6 == ls.reduce(0, |acc, a| => acc + a) && [2, 1, 3] == ls)
            fail(|| => ls.reduce(0, || => null),      "ArityMismatch: reduce function must have 2 parameters")
            fail(|| => ls.reduce(0, |a| => null),     "ArityMismatch: reduce function must have 2 parameters")
            fail(|| => ls.reduce(0, fn(a...) {}),     "ArityMismatch: reduce function must have 2 parameters")
            fail(|| => ls.reduce(0, fn(a, b = 2) {}), "ArityMismatch: reduce function must have 2 parameters")

            assert([2, 1] == ls.filter(|a| => a < 3) && [2, 1, 3] == ls)
            fail(|| => ls.filter(|a| => 0), 'TypeMismatch: filter function must return Bool, not Int')

            fail(|| => ls.filter(|| => null),      "ArityMismatch: filter function must have 1 parameter")
            fail(|| => ls.filter(|a,b| => null),   "ArityMismatch: filter function must have 1 parameter")
            fail(|| => ls.filter(fn(a...) {}),     "ArityMismatch: filter function must have 1 parameter")
            fail(|| => ls.filter(fn(a, b = 2) {}), "ArityMismatch: filter function must have 1 parameter")

            fail(|| => ls.sort(|a,b| => 0), 'ImmutableValue')

            ls = [2, 1, 3]
            assert([1, 2, 3] == ls.sort() && [1, 2, 3] == ls)
            assert([3, 2, 1] == ls.sort(|a,b| => b < a) &&  [3, 2, 1] == ls)
            fail(|| => ls.sort(|a,b| => 0), 'TypeMismatch: sort function must return Bool, not Int')

            fail(|| => ls.sort(|| => null),      "ArityMismatch: sort function must have 2 parameters")
            fail(|| => ls.sort(|a| => null),     "ArityMismatch: sort function must have 2 parameters")
            fail(|| => ls.sort(fn(a...) {}),     "ArityMismatch: sort function must have 2 parameters")
            fail(|| => ls.sort(fn(a, b = 2) {}), "ArityMismatch: sort function must have 2 parameters")
        },
        fn () {
            const ls = [3, 4, 5]
            assert(ls[0] == 3)
            assert(ls[2] == 5)
            assert(ls[0:3] == [3, 4, 5])
            assert(ls[2:3] == [5])
            const a = [1, 2, 3]
            let n = 0
            const b = a.map(fn(x) { n += x; x*x; })
            assert(b == [1, 4, 9] && n == 6)

            fail(|| => [].remove('a'), 'TypeMismatch: Expected Int, not Str')
        },
        fn () {
            const ls = [3,4,5];
            assert(ls[0:1] == [3]);
            assert(ls[1:3] == [4,5]);
            assert(ls[-2:-1] == [4]);
            assert(ls[-5:-4] == []);
            assert(ls[3:4] == []);
            assert(ls[3:2] == []);
            assert(ls[1:0] == []);

            const a = [1, 2, 3]
            assert([false, false, false, false] == [a, a[0:1], a[0:], a[:1]].map(frozen))
            freeze(a)
            assert([true, true, true, true] == [a, a[0:1], a[0:], a[:1]].map(frozen))
        },
        fn () {
            const a = set {11, 2, 31, 4, 5}
            const b = [].addAll(a)
            const c = set{}.addAll(b)
            assert(a == c)

            const d = dict {'x': 1, 2: 'y'}
            const e = set{}.addAll(d)
            const f = [].addAll(e)
            const g = dict{}.addAll(f)
            assert(d == g)
        },
        fn () {
            const a = set{1, 2, 3, 4, 5}
            const b = [].addAll(a).map(|e| => ((e, e*e), (e*e*e)))
            const c = dict{}.addAll(b)
            const d = [].addAll(c)

            const e = set{}
            for t in d {
                e.add(t[0][0])
                e.add(t[0][1])
                e.add(t[1])
            }

            assert(b == [ ((1, 1), 1), ((2, 4), 8), ((3, 9), 27), ((4, 16), 64), ((5, 25), 125) ])
            assert(c == dict{ (1, 1): 1, (2, 4): 8, (3, 9): 27, (4, 16): 64, (5, 25): 125 })
            assert(e == set { 1, 2, 3, 4, 5, 8, 9, 16, 64, 25, 27, 125 })
        },
        fn () {
            assert([1,2,3,4] == [2,1,4,3].sort())
        }
    ]
    for f in funcs { f(); }
}

fn testDict() {

    assert(dict {} == dict{})
    assert(dict {'a': 1} == dict{'a': 1})
    assert(dict {'a': 1, 'b': 2} == dict{'a': 1, 'b': 2})
    assert(dict {'a': 1, 'b': 2, 'c': 3} == dict{'a': 1, 'b': 2, 'c': 3})

    assert(dict {'a': 1, 'b': 2, 'c': 3} != dict{'a': 1, 'b': 2, 'd': 4})
    assert(dict {'a': 1, 'b': 2, 'c': 3} != dict{'a': 1, 'b': 2})
    assert(dict {'a': 1, 'b': 2, 'c': 3} != dict{'a': 1})
    assert(dict {'a': 1, 'b': 2, 'c': 3} != dict{})

    const x = dict{}
    const y = dict{'a': 1}

    assert(x == x)
    assert(y == y)
    assert(x != y)
    assert(y != x)
    assert(x != 'z')
    assert('z' != y)

    assert(!frozen(x))
    assert(x == freeze(x))
    assert(frozen(x))
    fail(|| => x.addAll(1), "ImmutableValue")
    fail(|| => x.remove(1), "ImmutableValue")
    fail(|| => x.clear(), "ImmutableValue")
    x.isEmpty()
    x.contains(1)

    assert(iter(x) != null)
    assert(len(x) == 0)
    assert(len(y) == 1)

    assert("dict { }" == str(dict {}))
    assert("dict { 1: a }" == str(dict {1:'a'}))
    assert("dict { 1: a, 2: b }" == str(dict {1:'a',2:'b'}))

    assert('Dict' == type(x))

    assert(set { 
        'isEmpty', 
        'contains', 

        'addAll',
        'clear',
        'remove' 
    } == fields(x))
    for f in fields(x) {
        assert(has(x, f))
    }
    assert(x.isEmpty == golem.getField(x, 'isEmpty'))
    assert(x.contains == golem.getField(x, 'contains'))

    assert(x.addAll == golem.getField(x, 'addAll'))
    assert(x.clear == golem.getField(x, 'clear'))
    assert(x.remove == golem.getField(x, 'remove'))

    assert(!has(x, 'bogus'))
    fail(|| => golem.getField(x, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.setField(x, 'bogus', null), "TypeMismatch: Expected Struct, not Dict")
    fail(|| => x.bogus = 1, "TypeMismatch: Expected Struct, not Dict")

    //-------------------------------------------------

    const funcs = [
        fn () {
            const d = dict {'x': 1, 'y': 2};
            d['x'] = 0;
            assert(d == dict {'y': 2, 'x': 0});
        },
        fn () {
            const a = dict { 'x': 1, 'y': 2 };
            const b = a['x'];
            const c = a['z'];
            a['x'] = -1;
            const d = a['x'];
            assert([1, null, -1] == [b, c, d])
        },
        fn () {
            const a = dict {};
            a.addAll([(1,2)]).addAll([(3,4)]);
            assert(a == dict {1:2,3:4});
            const b = dict {};
            assert(a.addAll == a.addAll);
            assert(b.addAll == b.addAll);
            assert(a.addAll != b.addAll);
            assert(b.addAll != a.addAll);
            assert(a.clear != a.addAll);
        },
        fn () {
            const a = dict{}
            fail(|| => a.addAll(false),      'TypeMismatch: Type Bool has no iter()')
            fail(|| => a.addAll([false]),    'TypeMismatch: Expected Tuple, not Bool')
            fail(|| => a.addAll([(1,2,3)]),  'InvalidArgument: Expected Tuple of length 2, not length 3')
            fail(|| => a[[1,2]],             'TypeMismatch: Type List cannot be hashed')
            fail(|| => a[[1,2]] = 3,         'TypeMismatch: Type List cannot be hashed')
            fail(|| => a.contains([1,2]), 'TypeMismatch: Type List cannot be hashed')
        },
        fn () {
            const a = dict {};
            assert(a.isEmpty());
            a[1] = 2;
            assert(!a.isEmpty());
            a.clear();
            assert(a.isEmpty());
        },
        fn () {
            const a = dict {'z': 3};
            assert(a.contains('z'));
            assert(!a.contains('x'));
        },
        fn () {
            const d = dict {'a': 1, 'b': 2};
            d.remove('z')
            d.remove('a')
            assert(d == dict {'b': 2});
            d.remove('b');
            assert(d == dict {});
            assert(len(d) == 0);
        },
        fn () {
            const d = dict {'a': 1, 'b': 2};
            d.remove('z');
            d.remove('a');
            assert(d == dict {'b': 2});
            d.remove('b');
            assert(d == dict {});
            assert(len(d) == 0);
        },
        fn () {
            const b = []
            b.addAll(range(0,3))
            b.addAll(dict { (true,false): 1, 'y': 2 })
            assert(b == [ 0, 1, 2, ((true,false), 1), ('y', 2)])
        },
        fn () {
            fail(|| => dict {null: 'b'}, 'NullValue')
            fail(|| => dict {[]: 'b'}, 'TypeMismatch: Type List cannot be hashed')
        }
    ]
    for f in funcs { f(); }
}

fn testSet() {

    assert(set {} == set{})
    assert(set {'a'} == set{'a'})
    assert(set {'a', 'b'} == set{'a', 'b'})
    assert(set {'a', 'b', 'c'} == set{'a', 'b', 'c'})

    assert(set {'a', 'b', 'c'} != set{'a', 'b', 'd'})
    assert(set {'a', 'b', 'c'} != set{'a', 'b'})
    assert(set {'a', 'b', 'c'} != set{'a'})
    assert(set {'a', 'b', 'c'} != set{})

    const x = set{}
    const y = set{'a'}

    assert(x == x)
    assert(y == y)
    assert(x != y)
    assert(y != x)
    assert(x != 'z')
    assert('z' != y)

    assert(!frozen(x))
    assert(x == freeze(x))
    assert(frozen(x))
    fail(|| => x.add(1), "ImmutableValue")
    fail(|| => x.addAll(1), "ImmutableValue")
    fail(|| => x.remove(1), "ImmutableValue")
    fail(|| => x.clear(), "ImmutableValue")
    x.isEmpty()
    x.contains(1)

    assert(iter(x) != null)
    assert(len(x) == 0)
    assert(len(y) == 1)

    assert("set { }" == str(set {}))
    assert("set { 1 }" == str(set {1}))
    assert("set { 1, 2 }" == str(set {1,2}))

    assert('Set' == type(x))

    assert(set { 
        'isEmpty', 
        'contains', 

        'add', 
        'addAll',
        'clear',
        'remove' 
    } == fields(x))
    for f in fields(x) {
        assert(has(x, f))
    }
    assert(x.isEmpty == golem.getField(x, 'isEmpty'))
    assert(x.contains == golem.getField(x, 'contains'))

    assert(x.add == golem.getField(x, 'add'))
    assert(x.addAll == golem.getField(x, 'addAll'))
    assert(x.clear == golem.getField(x, 'clear'))
    assert(x.remove == golem.getField(x, 'remove'))

    assert(!has(x, 'bogus'))
    fail(|| => golem.getField(x, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.setField(x, 'bogus', null), "TypeMismatch: Expected Struct, not Set")
    fail(|| => x.bogus = 1, "TypeMismatch: Expected Struct, not Set")

    //-------------------------------------------------

    const funcs = [
        fn () {
            const a = set {};
            a.add(1);
            assert(a == set {1});
            a.add(2).add(3).add(2);
            assert(a == set {1,2,3});
            assert(set {3,1,2} == set {1,2,3});
            assert(set {1,2} != set {1,2,3});
            const b = set { 4 };
            b.add(4);
            assert(b == set { 4 });
            assert(a.add == a.add);
            assert(b.add == b.add);
            assert(a.add != b.add);
            assert(b.add != a.add);
        },
        fn () {
            const a = set {};
            a.addAll([1,2]).addAll('bc');
            assert(a == set {1,2,'b','c'});
            const b = set {};
            b.addAll(range(0,3));
            assert(b == set { 0, 1, 2 });
            assert(a.addAll == a.addAll);
            assert(b.addAll == b.addAll);
            assert(a.addAll != b.addAll);
            assert(b.addAll != a.addAll);
            assert(a.add != a.addAll);
        },
        fn () {
            fail(|| => set{}.addAll(false),   'TypeMismatch: Type Bool has no iter()')
            fail(|| => set{}.add(3,4),        'ArityMismatch: Expected 1 parameter, got 2')
            fail(|| => set{}.add([1,2]),      'TypeMismatch: Type List cannot be hashed')
            fail(|| => set{}.contains([1,2]), 'TypeMismatch: Type List cannot be hashed')
            fail(|| => set {'a', 'b', null},  'NullValue')
            fail(|| => set {'a', 'b', []},    'TypeMismatch: Type List cannot be hashed')
        },
        fn () {
            const a = set{};
            assert(a.isEmpty());
            a.add(1);
            assert(!a.isEmpty());
            a.clear();
            assert(a.isEmpty());
        },
        fn () {
            let a = set{};
            assert(!a.contains('x'));
            a = set {'z', 'x'};
        },
        fn () {
            const s = set {'a', 'b', 'c'};
            s.remove('z').remove('a')
            assert(s == set {'c', 'b'});
            s.remove('b');
            assert(s == set {'c'});
            assert(len(s) == 1);
            s.remove('c');
            assert(s == set {});
            assert(len(s) == 0);
        }
    ]
    for f in funcs { f(); }
}

fn testTuple() {

    assert((1,2) == (1,2))
    assert((1,2,3) == (1,2,3))
    assert((1,2,3) != (1,2,4))
    assert((1,2,3) != (1,2))

    const x = (1, 2)
    const y = (3, 4, 5)

    assert(x == x)
    assert(y == y)
    assert(x != y)
    assert(y != x)
    assert(x != 'z')
    assert('z' != y)

    assert(frozen(x))
    assert(x == freeze(x))
    assert(frozen(x))

    fail(|| => iter(x), "TypeMismatch: Type Tuple has no iter()")
    assert(len(x) == 2)
    assert(len(y) == 3)

    assert('(1, 2)' == str(x))
    assert('(3, 4, 5)' == str(y))

    assert('Tuple' == type(x))

    assert(set { } == fields(x))

    assert(!has(x, 'bogus'))
    fail(|| => golem.getField(x, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.setField(x, 'bogus', null), "TypeMismatch: Expected Struct, not Tuple")
    fail(|| => x.bogus = 1, "TypeMismatch: Expected Struct, not Tuple")

    //-----------------------------------------------

    assert([1, 2] == [x[0], x[1]])
}

fn testChan() {

    const p = chan()
    const q = chan(1)

    assert(p == p)
    assert(q == q)
    assert(p != q)
    assert(q != p)
    assert(p != 'z')
    assert('z' != q)

    assert(frozen(p))
    assert(p == freeze(p))
    assert(frozen(p))

    fail(|| => iter(p), "TypeMismatch: Type Chan has no iter()")
    fail(|| => len(p), "TypeMismatch: Type Chan has no len()")

    assert(str(p).hasPrefix('chan<'))
    assert('Chan' == type(p))

    assert(set { 
        'send', 
        'recv' 
    } == fields(p))
    for f in fields(p) {
        assert(has(p, f))
    }
    assert(p.send == golem.getField(p, 'send'))
    assert(p.recv == golem.getField(p, 'recv'))

    assert(!has(p, 'bogus'))
    fail(|| => golem.getField(p, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.setField(p, 'bogus', null), "TypeMismatch: Expected Struct, not Chan")
    fail(|| => p.bogus = 1, "TypeMismatch: Expected Struct, not Chan")

    //-------------------------------------------------

    fn sum(s, c) {
        c.send(s.reduce(0, |acc, x| => acc+x))
    }

    let s = [7, 2, 8, -9, 4, 0]
    let n = len(s)/2
    let c = chan()

    go sum(s[:n], c)
    go sum(s[n:], c)

    let result = [c.recv(), c.recv()]
    assert(result == [-5, 17] || result == [17, -5])
}

fn testArity() {

    fail(|| => arity(0), 'TypeMismatch: Expected Func, not Int')

    assert(arity(println) == struct { kind: "Variadic", required: 0 })
    assert(arity(len)     == struct { kind: "Fixed",    required: 1 })
    assert(arity(range)   == struct { kind: "Multiple", required: 2, optional: 1 })

    const v = []
    const d = 
        dict{}.addAll(
            [].addAll(fields(v))
                .map(|n| => (n, arity(golem.getField(v, n)))))

    //// TODO
    //const v = []
    //const s = stream(fields(v))
    //    .map(|n| => struct { name: n, field: golem.getField(v, n) })
    //    .map(|s| => (s.name, arity(s.field)))
    //const d = dict{}.addAll(s.toIter())  // option 1
    //const e = s.toDict()                 // option 2

    assert(d ==
        dict { 
            "add":      struct { kind: "Fixed", required: 1 }, 
            "addAll":   struct { kind: "Fixed", required: 1 }, 
            "clear":    struct { kind: "Fixed", required: 0 }, 
            "contains": struct { kind: "Fixed", required: 1 }, 
            "filter":   struct { kind: "Fixed", required: 1 }, 
            "index":    struct { kind: "Fixed", required: 1 }, 
            "isEmpty":  struct { kind: "Fixed", required: 0 }, 
            "map":      struct { kind: "Fixed", required: 1 }, 
            "reduce":   struct { kind: "Fixed", required: 2 }, 
            "remove":   struct { kind: "Fixed", required: 1 },
            "sort":     struct { kind: "Multiple", required: 0, optional: 1 },
            "join":     struct { kind: "Multiple", required: 0, optional: 1 } 
        })
}

fn testVariadic() {

    const f = fn(v...) {
        return v
    }

    const g = fn(a, v...) {
        return (a, v)
    }

    const h = fn(a, b, v...) {
        return (a, b, v)
    }

    assert(f()           == [ ])
    assert(f(0)          == [ 0 ])
    assert(f(0, 1)       == [ 0, 1 ])
    assert(f(0, 1, 2)    == [ 0, 1, 2 ])
    assert(f(0, 1, 2, 3) == [ 0, 1, 2, 3 ])

    fail(|| => g(), 'ArityMismatch: Expected at least 1 parameter, got 0')
    assert(g(0)          == (0, [ ]))
    assert(g(0, 1)       == (0, [ 1 ]))
    assert(g(0, 1, 2)    == (0, [ 1, 2 ]))
    assert(g(0, 1, 2, 3) == (0, [ 1, 2, 3 ]))

    fail(|| => h(),  'ArityMismatch: Expected at least 2 parameters, got 0')
    fail(|| => h(0), 'ArityMismatch: Expected at least 2 parameters, got 1')
    assert(h(0, 1)       == (0, 1, [ ]))
    assert(h(0, 1, 2)    == (0, 1, [ 2 ]))
    assert(h(0, 1, 2, 3) == (0, 1, [ 2, 3 ]))

    assert([f, g, h].map(arity) ==
        [ struct { kind: "Variadic", required: 0 }, 
          struct { kind: "Variadic", required: 1 }, 
          struct { kind: "Variadic", required: 2 } ])
}

fn testMultiple() {

    const f = fn(a = 1, b = 2, c = 3) {
        return (a, b, c)
    }

    const g = fn(a, b = 2, c = 3) {
        return (a, b, c)
    }

    const h = fn(a, b, c = 3) {
        return (a, b, c)
    }

    assert(f()              == (1, 2, 3))
    assert(f('x')           == ('x', 2, 3))
    assert(f('x', 'y')      == ('x', 'y', 3))
    assert(f('x', 'y', 'z') == ('x', 'y', 'z'))
    fail(|| => f('x', 'y', 'z', 0), 'ArityMismatch: Expected at most 3 parameters, got 4')

    fail(|| => g(), 'ArityMismatch: Expected at least 1 parameter, got 0')
    assert(g('x')           == ('x', 2, 3))
    assert(g('x', 'y')      == ('x', 'y', 3))
    assert(g('x', 'y', 'z') == ('x', 'y', 'z'))
    fail(|| => g('x', 'y', 'z', 0), 'ArityMismatch: Expected at most 3 parameters, got 4')

    fail(|| => h(),    'ArityMismatch: Expected at least 2 parameters, got 0')
    fail(|| => h('x'), 'ArityMismatch: Expected at least 2 parameters, got 1')
    assert(h('x', 'y')      ==  ('x', 'y', 3))
    assert(h('x', 'y', 'z') ==  ('x', 'y', 'z'))
    fail(|| => h('x', 'y', 'z', 0), 'ArityMismatch: Expected at most 3 parameters, got 4')
}

fn testRange() {

    assert(range(0, 0) == range(0, 0))
    assert(range(0, 0) != range(0, 1))

    const x = range(0, 0)
    const y = range(2, 3)

    assert(x == x)
    assert(y == y)
    assert(x != y)
    assert(y != x)
    assert(x != 'z')
    assert('z' != y)

    assert(frozen(x))
    assert(x == freeze(x))
    assert(frozen(x))

    assert(iter(x) != null)
    assert(len(x) == 0)
    assert(len(y) == 1)

    assert("range<0, 0, 1>" == str(x))
    assert("range<2, 3, 1>" == str(y))

    assert('Range' == type(x))

    const rng = range(0, 10)
    assert(set { 'to', 'count', 'step', 'from' } == fields(rng))
    for f in fields(rng) {
        assert(has(rng, f))
    }
    assert(rng.to == golem.getField(rng, 'to'))
    assert(rng.count == golem.getField(rng, 'count'))
    assert(rng.step == golem.getField(rng, 'step'))
    assert(rng.from == golem.getField(rng, 'from'))

    assert(!has(rng, 'bogus'))
    fail(|| => golem.getField(rng, 'bogus'), "NoSuchField: Field 'bogus' not found")
    fail(|| => golem.setField(rng, 'bogus', null), "TypeMismatch: Expected Struct, not Range")
    fail(|| => rng.bogus = 1, "TypeMismatch: Expected Struct, not Range")

    //-----------------------------------------

    fail(|| => iter(range(0,0)).get(), 'NoSuchElement')

    const a = range(0, 5)
    const b = range(0, 5, 2)
    const c = range(2, 14, 3)
    const d = range(-1, -8, -3)
    const e = range(2, 2)
    const f = range(-1, -1, -1)
    const g = range(2, 1, 1)
    const h = range(1, 2, -1)

    assert(listify(a) == [ 0, 1, 2, 3, 4 ])
    assert(listify(b) == [ 0, 2, 4 ])
    assert(listify(c) == [ 2, 5, 8, 11 ])
    assert(listify(d) == [ -1, -4, -7 ])
    assert(listify(e) == [])
    assert(listify(f) == [])
    assert(listify(g) == [])
    assert(listify(h) == [])

    assert(iterate(a) == [ 0, 1, 2, 3, 4 ])
    assert(iterate(b) == [ 0, 2, 4 ])
    assert(iterate(c) == [ 2, 5, 8, 11 ])
    assert(iterate(d) == [ -1, -4, -7 ])
    assert(iterate(e) == [])
    assert(iterate(f) == [])
    assert(iterate(g) == [])
    assert(iterate(h) == [])

    assert([a.from(), a.to(), a.step(), a.count()] == [0, 5, 1, 5])
    assert([b.from(), b.to(), b.step(), b.count()] == [0, 5, 2, 3])
    assert([c.from(), c.to(), c.step(), c.count()] == [2, 14, 3, 4])
    assert([d.from(), d.to(), d.step(), d.count()] == [-1, -8, -3, 3])
    assert([e.from(), e.to(), e.step(), e.count()] == [2, 2, 1, 0])
    assert([f.from(), f.to(), f.step(), f.count()] == [-1, -1, -1, 0])
    assert([g.from(), g.to(), g.step(), g.count()] == [2, 1, 1, 0])
    assert([h.from(), h.to(), h.step(), h.count()] == [1, 2, -1, 0])

    let i = 0
    const ls = [2, 5, 8, 11]
    while i < c.count() {
        assert(c[i] == ls[i])
        i++
    } 
    assert(i == 4)

    fail(|| => range(0, 0, 0), "InvalidArgument: step cannot be 0")
}

fn testStruct() {

    fail(|| => len(struct{}), 'TypeMismatch: Type Struct has no len()')
    fail(|| => iter(struct{}), 'TypeMismatch: Type Struct has no iter()')

    assert("struct { }" == str(struct {}))
    assert("struct { a: 1 }" == str(struct {a: 1}))

    //-----------------------------------------

    const funcs = [
        fn () {
            assert(struct {} == struct{})
            assert(struct {a: 1} == struct{a: 1})
            assert(struct {a: 1, b: 2} == struct{a: 1, b: 2})
            assert(struct {a: 1, b: 2, c: 3} == struct{a: 1, b: 2, c: 3})

            assert(struct {a: 1, b: 2, c: 3} != struct{a: 1, b: 2, d: 4})
            assert(struct {a: 1, b: 2, c: 3} != struct{a: 1, b: 2})
            assert(struct {a: 1, b: 2, c: 3} != struct{a: 1})
            assert(struct {a: 1, b: 2, c: 3} != struct{})

            const x = struct{}
            const y = struct{a: 1}

            assert(x == x)
            assert(y == y)
            assert(x != y)
            assert(y != x)
            assert(x != 'z')
            assert('z' != y)

            assert(!frozen(y))
            assert(y == freeze(y))
            assert(frozen(y))
            fail(|| => y.a = 2, "ImmutableValue")

            assert('Struct' == type(x))

            assert(!has(x, 'bogus'))
            fail(|| => golem.getField(x, 'bogus'), "NoSuchField: Field 'bogus' not found")
            fail(|| => golem.setField(x, 'bogus', null), "NoSuchField: Field 'bogus' not found")
            fail(|| => x.bogus = 1, "NoSuchField: Field 'bogus' not found")
        },
        fn () {
            const w = struct {}
            const x = struct { a: 0 }
            const y = struct { a: 1, b: 2 }
            const z = struct { a: 3, b: 4, c: struct { d: 5 } }

            assert([0] == [x.a])
            assert([1, 2] == [y.a, y.b])
            assert([3, 4, 5] == [z.a, z.b, z.c.d])

            for s in [w, x, y, z] {
                fail(|| => s.bogus, "NoSuchField: Field 'bogus' not found")
            }
        },
        fn () {
            const x = struct { a: 5 }
            const y = x.a
            x.a = 6
            assert([5, 6] == [y, x.a])
        },
        fn () {
            const a = struct {
                x: 8,
                y: 5,
                plus:  fn() { return this.x + this.y; },
                minus: fn() { return this.x - this.y; }
            }
            const b = a.plus()
            const c = a.minus()
            assert([13, 3] == [b, c])
        },
        fn () {
            let a = null
            a = struct { x: 8 }.x = 5
            assert(5 == a)
        },
        fn () {
            const s = struct { 
                a: prop { || => 1 } 
            }
            assert(1 == s.a)
            fail(|| => s.a = 2, "ReadonlyField: Field 'a' is readonly")
        },
        fn () {
            let x = 2
            const s = struct { 
                a: prop { || => 1 } ,
                b: prop { || => x, |v| => x = v },
                c: || => this.a + this.b
            }
            fail(|| => s.a = 2, "ReadonlyField: Field 'a' is readonly")

            assert([s.a, s.b, x, s.c()] == [1, 2, 2, 3])

            s.b = 3
            assert([s.a, s.b, x, s.c()] == [1, 3, 3, 4])

            x = 4
            assert([s.a, s.b, x, s.c()] == [1, 4, 4, 5])
        },
        fn () {
            fn newRectangle(w, h) {
                return struct {
                    width:  prop { || => w, |val| => w = val },
                    height: prop { || => h, |val| => h = val },
                    area:   || => w * h
                }
            }

            fn newBox(rect, d) {
                return merge(
                    rect, 
                    struct {
                        depth:  prop { || => d, |val| => d = val },
                        volume: || => rect.area() * d
                    })
            }

            const r = newRectangle(2, 3)
            const b = newBox(r, 4)

            assert(fields(r) == set { 'width', 'height', 'area' })
            assert(fields(b) == set { 'width', 'depth', 'height', 'volume', 'area' })

            assert([b.width, b.height, b.depth, b.area(), b.volume()] == [2, 3, 4, 6, 24])
            r.width = 5
            assert([b.width, b.height, b.depth, b.area(), b.volume()] == [5, 3, 4, 15, 60])
        }
    ]
    for f in funcs { f(); }
}

fn testMerge() {

    fail(|| => merge(), 'ArityMismatch: Expected at least 2 parameters, got 0')
    fail(|| => merge(true), 'ArityMismatch: Expected at least 2 parameters, got 1')
    fail(|| => merge(struct{}, false), 'TypeMismatch: Expected Struct, not Bool')
    fail(|| => merge(struct{}, struct{}, struct{}, []), 'TypeMismatch: Expected Struct, not List')

    const a = struct { x: 1, y: 2}
    const b = merge(a, struct { y: 3, z: 4})
    assert(b.x == 1)
    assert(b.y == 3)
    assert(b.z == 4)
    a.x = 5
    a.y = 6
    assert(b.x == 5)
    assert(b.y == 3)
    assert(b.z == 4)
    const c = merge(b, struct { w: 10})
    assert(c.x == 5)
    assert(c.y == 3)
    assert(c.z == 4)
    assert(c.w == 10)
    a.x = 7
    b.z = 11
    assert(c.x == 7)
    assert(c.y == 3)
    assert(c.z == 11)
    assert(c.w == 10)

    const z = merge(struct { a: 1}, struct { b: 2}, struct { c: 3}, struct { d: 4})
    assert(struct { a: 1, b: 2, c: 3, d: 4} == z)

    const f = freeze(struct { x: 1, y: 2})
    const g = freeze(struct { x: 3, z: 4})
    const h = merge(f, g)
    assert(struct { x: 3, y: 2, z: 4} == h)

    const ls = [a, b, c, f, g, h].map(frozen)
    assert([ false, false, false, true, true, true ] == ls)

    let error = 'InvalidArgument: Cannot merge structs unless they are all frozen, or all unfrozen'
    fail(|| => merge(a, b, f), error)
    fail(|| => merge(a, f, b), error)
    fail(|| => merge(f, a, b), error)
    fail(|| => merge(f, g, b), error)
}

fn testTry() {

    const funcs = [
        fn () {
			let a = 0
			try {
				1/0
			} catch e {
				a = 1
			}
			assert(a == 1)
        },
        fn () {
			let b = 0
			try {
				1/0
			} finally {
				b = 1
			}
			assert(b == 1)
        },
        fn () {
			let a = 0
			let b = 0
			try {
				1/0
			} catch e {
				a = 1
			} finally {
				b = 1
			}
			assert(a == 1)
			assert(b == 1)
        },
        fn () {
			let a = 0
			try {
				let b = 0
				try {
					1/0
				} finally {
					b = 1
				}
				assert(b == 1)
			} catch e {
				a = 1
			}
			assert(a == 0)
        },
        fn () {
			let b = 0
			try {
				let a = 0
				try {
					1/0
				} catch e {
					a = 1
				}
				assert(a == 1)
			} finally {
				b = 1
			}
			assert(b == 1)
        },

        //====================================
        //------------------------------------
        // return, return
        fn () {
            fn a() {
                try {
                    1/0
                } catch e {
                    return 'x'
                } finally {
                    return 'y'
                }
                assert(false)
            }
            assert(a() == 'y')
        },
        //------------------------------------
        // return, err
        fn () {
            fn a() {
                try {
                    1/0
                } catch e {
                    return 'x'
                } finally {
                    throw 'TestError: y'
                }
                assert(false)
            }
            fail(a, 'TestError: y')
        },
        //------------------------------------
        // return, nothing
        fn () {
            let n = 0
            fn a() {
                try {
                    1/0
                } catch e {
                    return 'x'
                } finally {
                    n++
                }
                assert(false)
            }
            assert(a() == 'x')
            assert(n == 1)
        },

        //====================================
        //------------------------------------
        // err, return
        fn () {
            fn a() {
                try {
                    1/0
                } catch e {
                    throw e
                } finally {
                    return 'y'
                }
                assert(false)
            }
            assert(a() == 'y')
        },
        //------------------------------------
        // err, err
        fn () {
            fn a() {
                try {
                    1/0
                } catch e {
                    throw e
                } finally {
                    throw 'TestError'
                }
                assert(false)
            }
            fail(a, 'TestError')
        },
        //------------------------------------
        // err, nothing
        fn () {
            let n = 0
            fn a() {
                try {
                    1/0
                } catch e {
                    throw e.error
                } finally {
                    n++
                }
                assert(false)
            }
            fail(a, 'DivideByZero')
            assert(n == 1)
        },

        //====================================
        //------------------------------------
        // nothing, return
        fn () {
            let n = 0
            fn a() {
                try {
                    1/0
                } catch e {
                    n++
                } finally {
                    return 'y'
                }
                assert(false)
            }
            assert(a() == 'y')
            assert(n == 1)
        },
        //------------------------------------
        // nothing, error
        fn () {
            let n = 0
            fn a() {
                try {
                    1/0
                } catch e {
                    n++
                } finally {
                    throw 'TestError'
                }
                assert(false)
            }
            fail(a, 'TestError')
            assert(n == 1)
        },
        //------------------------------------
        // nothing, nothing
        fn () {
            let p = 0
            let q = 0
            fn a() {
                try {
                    1/0
                } catch e {
                    p++
                } finally {
                    q++
                }
                return 'z'
            }
            assert(a() == 'z')
            assert(p == 1)
            assert(q == 1)
        },

        //====================================
        fn () {
            let p = 0
            let q = 0

            fn a() {
                try {
                    1/0
                } catch e {
                    throw e.error
                } finally {
                    q++
                }
                assert(false)
            }

            fn b() {
                a()
            }

            fn c() {
                try {
                    b()
                } catch e {
                    assert(e.error == 'DivideByZero')
                    p++
                } finally {
                    throw 'TestError'
                }
                assert(false)
            }

            fn d() {
                c()
            }

            fail(a, 'DivideByZero')
            assert([p,q] == [0,1])

            fail(b, 'DivideByZero')
            assert([p,q] == [0,2])

            fail(c, 'TestError')
            assert([p,q] == [1,3])

            fail(d, 'TestError')
            assert([p,q] == [2,4])
        },
        fn () {
            fn a() {
                try {
                    throw 'a'
                }
                catch e {
                    [1].map(fn(e) {
                        let s = struct {
                            p: prop { || => 1/0 }
                        }
                        s.p
                    })
                }
            }
        }
    ]
    let n = 0
    for f in funcs { 
        n++
        f() 
    }
    // sanity check that the instruction pointer didn't get lost
    assert(n == len(funcs))
}

fn main(args) {

    let funcs = [

        ('testExpressions', testExpressions),
        ('testAssignment',  testAssignment),
        ('testFlowControl', testFlowControl),
        ('testTry',         testTry),

        ('testNull',  testNull),
        ('testBool',  testBool),
        ('testStr',   testStr),
        ('testInt',   testInt),
        ('testFloat', testFloat),

        ('testFunc',      testFunc),
        ('testCapture',   testCapture),
        ('testNamedFunc', testNamedFunc),
        ('testLambda',    testLambda),
        ('testArity',     testArity),
        ('testVariadic',  testVariadic),
        ('testMultiple',  testMultiple),

        ('testChan', testChan),

        ('testList',   testList),
        ('testRange',  testRange),
        ('testTuple',  testTuple),
        ('testDict',   testDict),
        ('testSet',    testSet),
        ('testStruct', testStruct),
        ('testMerge',  testMerge)

    ]
    for f in funcs { 
        println('    ', f[0])
        f[1]() 
    }
}

