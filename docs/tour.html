<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Golem Tour</title>

        <link type="text/css" rel="stylesheet" href="style.css">
        <script src="wasm_exec.js"></script>
        <script src="wasm_init.js"></script>
    </head>
    <body>
        <div class="div-wrapper">


<h1 id="a-tour-of-golem">A Tour of Golem</h1>
<p>Welcome to the tour of the Golem Programming Language.</p>
<ul>
<li><a href="#hello-world">Hello, world</a></li>
<li><a href="#basic-types">Basic Types</a></li>
<li><a href="#comments">Comments</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#collections">Collections</a>
<ul>
<li><a href="#list">List</a></li>
<li><a href="#dict">Dict</a></li>
<li><a href="#set">Set</a></li>
<li><a href="#tuple">Tuple</a></li>
<li><a href="#len"><code>len</code></a></li>
</ul></li>
<li><a href="#fields">Fields</a></li>
<li><a href="#control-structures">Control Structures</a></li>
<li><a href="#functions">Functions</a>
<ul>
<li><a href="#function-syntax">Function Syntax</a></li>
<li><a href="#lambdas">Lambdas</a></li>
<li><a href="#named-functions">Named Functions</a></li>
<li><a href="#closures">Closures</a></li>
<li><a href="#optional-parameters">Optional Parameters</a></li>
<li><a href="#variadic-functions">Variadic Functions</a></li>
<li><a href="#arity">Arity</a></li>
</ul></li>
<li><a href="#structs">Structs</a>
<ul>
<li><a href="#struct-syntax">Struct Syntax</a></li>
<li><a href="#properties">Properties</a></li>
<li><a href="#merging-structs">Merging Structs</a></li>
<li><a href="#using-structs-to-build-complex-values">Using Structs to build complex values</a></li>
</ul></li>
<li><a href="#errors">Errors</a></li>
<li><a href="#concurrency">Concurrency</a></li>
<li><a href="#immutability">Immutability</a></li>
<li><a href="#introspection">Introspection</a></li>
<li><a href="#command-line-executable">Command Line Executable</a>
<ul>
<li><a href="#modules">Modules</a></li>
<li><a href="#the-main-function">The <code>main()</code> function</a></li>
<li><a href="#standard-library">Standard Library</a></li>
<li><a href="#examples">Examples</a></li>
</ul></li>
<li><a href="#embedding">Embedding</a></li>
</ul>
<h2 id="hello-world">Hello, world</h2>
<p>Let’s get started with the proverbial hello world program. In this tour, we will be running Golem code directly in the browser, so press the <code>Run</code> button below to see the output of the program:</p>
<div class="play">
    <div class="input">
        <textarea id="src28" rows="1" spellcheck="false">println(&#39;Hello, world.&#39;);</textarea>
    </div>
    <div class="output"><pre id="result28"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src28', 'result28');">Run</button>
    </div>
</div>

<p>You may have noticed that there is a semicolon at the end of the <a href="builtins.html#println"><code>println</code></a> statement. Semicolons are usually optional in Golem – they are required only if you want to write multiple separate statements on a single line. We will omit unnecessary semicolons in the rest of the tour.</p>
<h2 id="basic-types">Basic Types</h2>
<p>Golem’s basic primitive types include <a href="bool.html">bool</a>, <a href="int.html">int</a>, <a href="float.html">float</a> and <a href="str.html">string</a> There is also <a href="null.html">null</a>, which represents the absence of a value. Basic values are immutable.</p>
<div class="play">
    <div class="input">
        <textarea id="src29" rows="6" spellcheck="false">println(null)
println(false)
println(true)
println(1 + 2)
println(3.0 / 4.0)
println(&#39;abc&#39; + &quot;def&quot;)</textarea>
    </div>
    <div class="output"><pre id="result29"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src29', 'result29');">Run</button>
    </div>
</div>

<p>Golem has the usual set of C-language-family <a href="syntax.html#operator-precedence">operators</a> that you would expect: <code>==</code>, <code>!=</code>, <code>||</code>, <code>&amp;&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>+</code>, <code>-</code>, and so forth.</p>
<p>Unlike many other dynamic languages, Golem has no concept of ‘truthiness’. The only things that are true or false are boolean values. So, <code>''</code>, <code>0</code>, <code>null</code>, etc. are <em>not</em> boolean, and and error will be thrown if you attempt to evaluate them in a place where a boolean value is expected.</p>
<h2 id="comments">Comments</h2>
<p>Golem uses C-language-family comments: <code>/* ... */</code> for a block comment, and <code>//</code> for a line comment.</p>
<h2 id="variables">Variables</h2>
<p>Values can be assigned to variables. Variables are declared via either the <code>let</code> or <code>const</code> keyword. It is an error to refer to a variable before it has been declared.</p>
<div class="play">
    <div class="input">
        <textarea id="src30" rows="4" spellcheck="false">let a = 1
const b = 2
a = b + 3
println(a)</textarea>
    </div>
    <div class="output"><pre id="result30"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src30', 'result30');">Run</button>
    </div>
</div>

<p>As you might expect, the value of a const variable cannot be changed once it has been assigned.</p>
<p><code>let</code> and <code>const</code> are “statements” – they do not return a value. Assignments, on the other, are <a href="#TODO">expressions</a>, and evaluating an expression returns a value:</p>
<div class="play">
    <div class="input">
        <textarea id="src31" rows="3" spellcheck="false">let a = 1
let b = (a = 2)
assert(a == b &amp;&amp; b == 2)</textarea>
    </div>
    <div class="output"><pre id="result31"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src31', 'result31');">Run</button>
    </div>
</div>

<h2 id="collections">Collections</h2>
<p>Golem has four collection data types: <a href="list.html">List</a>, <a href="dict.html">Dict</a>, <a href="set.html">Set</a>, and <a href="tuple.html">Tuple</a></p>
<h3 id="list">List</h3>
<p>You can create a list by enclosing a comma-delimited sequence of values in square brackets. Once you’ve created a list, you can use square brackets to access individual elements of a list (this is called the “index operator”).</p>
<div class="play">
    <div class="input">
        <textarea id="src32" rows="5" spellcheck="false">let a = []
let b = [3,4,5]
assert(a.isEmpty())
assert(b[0] == 3)
println(b[-1]) // negative indexes start from the end</textarea>
    </div>
    <div class="output"><pre id="result32"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src32', 'result32');">Run</button>
    </div>
</div>

<p>Use the “slice operator” to create a new list from part of an existing list. If you leave off the first or last value of the slice operation, the resulting slice will start at the beginning or end. Negative values work with slices in the same way that they do with indexes.</p>
<div class="play">
    <div class="input">
        <textarea id="src33" rows="5" spellcheck="false">let c = [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]
println(c[1:3])
println(c[:3])
println(c[2:])
println(c[1:-1])</textarea>
    </div>
    <div class="output"><pre id="result33"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src33', 'result33');">Run</button>
    </div>
</div>

<p>Indexing and slicing works on strings too:</p>
<div class="play">
    <div class="input">
        <textarea id="src34" rows="2" spellcheck="false">println(&#39;abc&#39;[1])
println(&#39;abc&#39;[:-1])</textarea>
    </div>
    <div class="output"><pre id="result34"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src34', 'result34');">Run</button>
    </div>
</div>

<h3 id="dict">Dict</h3>
<p>Golem’s <code>dict</code> type is an <a href="https://en.wikipedia.org/wiki/Associative_array">associative array</a>. The keys of a dict can be any value that supports <a href="interfaces.html#hashable">hashing</a>.</p>
<div class="play">
    <div class="input">
        <textarea id="src35" rows="4" spellcheck="false">let a = dict {&#39;x&#39;: 1, &#39;y&#39;: 2}
println(a[&#39;x&#39;])
a[&#39;z&#39;] = 3
println(a)</textarea>
    </div>
    <div class="output"><pre id="result35"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src35', 'result35');">Run</button>
    </div>
</div>

<h3 id="set">Set</h3>
<p>A <code>set</code> is a unordered collection of distinct values. Any value that can act as a key in a dict can be a member of a set.</p>
<div class="play">
    <div class="input">
        <textarea id="src36" rows="3" spellcheck="false">let a = set {&#39;x&#39;, &#39;y&#39;}
println(a)
println(a.contains(&#39;x&#39;))</textarea>
    </div>
    <div class="output"><pre id="result36"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src36', 'result36');">Run</button>
    </div>
</div>

<h3 id="tuple">Tuple</h3>
<p>A <code>tuple</code> is an immutable list-like data structure. Tuples must have at least two values.</p>
<div class="play">
    <div class="input">
        <textarea id="src37" rows="2" spellcheck="false">let a = (1, 2)
println(a)</textarea>
    </div>
    <div class="output"><pre id="result37"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src37', 'result37');">Run</button>
    </div>
</div>

<h3 id="len"><code>len</code></h3>
<p>The builtin function <a href="builtins.html#len"><code>len</code></a> can be used to get the length of any of the collections. <code>len</code> will also return the length of a string.</p>
<div class="play">
    <div class="input">
        <textarea id="src38" rows="4" spellcheck="false">let a = [1, 2, 3]
let b = &#39;lmnop&#39;
let c = dict {&quot;x&quot;: 3}
println([len(a), len(b), len(c)])</textarea>
    </div>
    <div class="output"><pre id="result38"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src38', 'result38');">Run</button>
    </div>
</div>

<h2 id="fields">Fields</h2>
<p>A “field” in Golem is a named member of a value. Each type has a collection of fields that are associated with a given value.</p>
<p>As an example, here is how to use some of the fields that are present on a list value:</p>
<div class="play">
    <div class="input">
        <textarea id="src39" rows="8" spellcheck="false">let ls = []
assert(ls.isEmpty())
ls.add(&#39;a&#39;)
ls.addAll([&#39;b&#39;, &#39;c&#39;])
println(ls)
println(ls.contains(&#39;c&#39;))
println(ls.index(&#39;b&#39;))
println(ls.join(&#39;,&#39;))</textarea>
    </div>
    <div class="output"><pre id="result39"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src39', 'result39');">Run</button>
    </div>
</div>

<p>Note that the fields we see in the above example – <code>isEmpty</code>, <code>add</code>, <code>addAll</code>, <code>contains</code>, <code>index</code>, and <code>join</code> – are all <a href="#functions">functions</a>. Most fields that are built in to the various Golem types are functions.</p>
<h2 id="control-structures">Control Structures</h2>
<p>Golem has a familiar set of control structures: <code>if</code>, <code>while</code>, <code>switch</code>, and <code>for</code>.</p>
<div class="play">
    <div class="input">
        <textarea id="src40" rows="5" spellcheck="false">let a = 2
while a &lt; 100 {
    a = a * a 
}
println(a)</textarea>
    </div>
    <div class="output"><pre id="result40"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src40', 'result40');">Run</button>
    </div>
</div>

<p>Golem also has <code>break</code> and <code>continue</code>, which will break out of a <code>while</code> or <code>for</code> loop, or continue at the top of the loop, as in other languages.</p>
<p>Golem has ‘ternary-if’ expressions as well:</p>
<div class="play">
    <div class="input">
        <textarea id="src41" rows="2" spellcheck="false">const a = 10
println(a &lt; 3 ? 4 : 5)</textarea>
    </div>
    <div class="output"><pre id="result41"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src41', 'result41');">Run</button>
    </div>
</div>

<p><code>switch</code> works roughly the same way as it does in other languages, except that you can switch on any value, not just integers. Also, there is no ‘fall-through’ – at most only one case will be executed. Therefore the <code>break</code> keyword is not applicable to switches.</p>
<div class="play">
    <div class="input">
        <textarea id="src42" rows="11" spellcheck="false">let a = &#39;abc&#39;
let b = 0
switch a {
    case 0:
        b = 1
    case &#39;abc&#39;:
        b = 2
    default:
        b = 3
}
println(b)</textarea>
    </div>
    <div class="output"><pre id="result42"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src42', 'result42');">Run</button>
    </div>
</div>

<p>You can have multiple expressions in a case statement. The body of the case will be executed if at least on of the expressions matches:</p>
<div class="play">
    <div class="input">
        <textarea id="src43" rows="12" spellcheck="false">let s = &#39;&#39;
let i = 0
while i &lt; 4 {
    switch i {
        case 0, 1:
            s += &#39;a&#39;
        case 2:
            s += &#39;b&#39;
    }
    i++
}
println(s)</textarea>
    </div>
    <div class="output"><pre id="result43"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src43', 'result43');">Run</button>
    </div>
</div>

<p>You can leave the expression out after the <code>switch</code> keyword. This lets you switch on a sequence of boolean case statements, which is sometimes easier to read than a cascade of ‘if, else-if, else-if’ statmements:</p>
<div class="play">
    <div class="input">
        <textarea id="src44" rows="7" spellcheck="false">let a = 0
switch {
    case a &lt; 1:
        println(&#39;foo&#39;)
    default:
        println(&#39;bar&#39;)
}</textarea>
    </div>
    <div class="output"><pre id="result44"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src44', 'result44');">Run</button>
    </div>
</div>

<p>Golem’s <code>for</code> statement iterates over a sequence of values derived from an <a href="interfaces.html#iterable">iterable</a> value.</p>
<div class="play">
    <div class="input">
        <textarea id="src45" rows="6" spellcheck="false">let a = [1, 2, 3]
let b = 0
for e in a {
    b += e
}
println(b)</textarea>
    </div>
    <div class="output"><pre id="result45"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src45', 'result45');">Run</button>
    </div>
</div>

<p>By convention, iterating over a dict produces a sequence of tuples. You can capture the values in the tuple directly in a <code>for</code> loop via “tuple destructuring”:</p>
<div class="play">
    <div class="input">
        <textarea id="src46" rows="7" spellcheck="false">let d = dict { &quot;x&quot;: 1, &quot;y&quot;: 2, &quot;z&quot;: 3 }
for e in d {
    println(e)
}
for (k, v) in d {
    println(&quot;key: &quot;, k, &quot;, value: &quot;, v)
}</textarea>
    </div>
    <div class="output"><pre id="result46"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src46', 'result46');">Run</button>
    </div>
</div>

<p>There is one more iterable type – ranges. Ranges are created via the <a href="builtins.html#range"><code>range</code></a> builtin function. A range is an immutable value that represents a sequence of integers.</p>
<div class="play">
    <div class="input">
        <textarea id="src47" rows="7" spellcheck="false">let list = [&quot;frog&quot;, &quot;cow&quot;, &quot;rabbit&quot;]
for i in range(0, len(list)) {
    if list[i] == &quot;cow&quot; {
        println(&quot;The cow is at element &quot;, i)
        break
    }
}</textarea>
    </div>
    <div class="output"><pre id="result47"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src47', 'result47');">Run</button>
    </div>
</div>

<p>Note that ranges do not actually contain a list of all the specified integers. They simply represent a sequence that can be iterated over.</p>
<h2 id="functions">Functions</h2>
<p>A <a href="func.html">Function</a> is a sequence of <a href="#TODO"><code>expressions</code></a> and <a href="#TODO"><code>statements</code></a> that can be invoked to perform a task. We have already encountered quite a few functions: builtin functions like <code>println</code>, and a few field functions like the ones on a list.</p>
<p>Functions are first-class values – they can be passed around just like any other value.</p>
<h3 id="function-syntax">Function Syntax</h3>
<p>Functions are created with the <code>fn</code> keyword:</p>
<div class="play">
    <div class="input">
        <textarea id="src48" rows="4" spellcheck="false">let a = fn(x) {
    return x * 7
}
assert(a(6) == 42)</textarea>
    </div>
    <div class="output"><pre id="result48"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src48', 'result48');">Run</button>
    </div>
</div>

<p>Functions do not have to have an explicit <code>return</code> statement. If there is no <code>return</code>, they will return the last expression that was evaluated. If no expression is evaluated in the function, <code>null</code> is returned.</p>
<div class="play">
    <div class="input">
        <textarea id="src49" rows="4" spellcheck="false">let a = fn() {}
let b = fn(x) { x * x; } // semicolon required here!
assert(a() == null)
assert(b(3) == 9)</textarea>
    </div>
    <div class="output"><pre id="result49"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src49', 'result49');">Run</button>
    </div>
</div>

<p>A <code>return</code> statement without a value is syntactically invalid – all return statements must include a value to return.</p>
<p>You can declare the formal parameters of a function to be constant. In the following example, the formal parameter ‘b’ is constant, so it cannot be changed inside the function:</p>
<div class="play">
    <div class="input">
        <textarea id="src50" rows="4" spellcheck="false">fn foo(const b) {
    return b + 42
}
println(foo(12))</textarea>
    </div>
    <div class="output"><pre id="result50"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src50', 'result50');">Run</button>
    </div>
</div>

<h3 id="lambdas">Lambdas</h3>
<p>Golem also supports ‘lambda’ syntax, via the <code>=&gt;</code> operator. Lambdas provide a lightweight way to define a function on the fly. The body of a lambda function is a single expression.</p>
<div class="play">
    <div class="input">
        <textarea id="src51" rows="6" spellcheck="false">let a = || =&gt; 3
let b = |x| =&gt; x * x
let c = |x, y| =&gt; (x + y) * 5
println(a())
println(b(2))
println(c(1, 2))</textarea>
    </div>
    <div class="output"><pre id="result51"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src51', 'result51');">Run</button>
    </div>
</div>

<p>Here is an example which passes lambdas to some list functions that expect a function as a parameter:</p>
<div class="play">
    <div class="input">
        <textarea id="src52" rows="7" spellcheck="false">const ls = [1, 2, 3, 4, 5]
let squares = ls.map(|x| =&gt; x * x)
let addedUp = ls.reduce(0, |acc, x| =&gt; acc + x)
let even = ls.filter(|x| =&gt; (x % 2 == 0))
println(squares)
println(addedUp)
println(even)</textarea>
    </div>
    <div class="output"><pre id="result52"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src52', 'result52');">Run</button>
    </div>
</div>

<h3 id="named-functions">Named Functions</h3>
<p>Consider the following program, in which function <code>a</code> calls function <code>b</code>:</p>
<div class="play">
    <div class="input">
        <textarea id="src53" rows="7" spellcheck="false">const b = fn() {
    return 42
}
const a = fn() {
    return b()
}
println(a())</textarea>
    </div>
    <div class="output"><pre id="result53"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src53', 'result53');">Run</button>
    </div>
</div>

<p>This program works because <code>b</code> is declared before <code>a</code>. However, if we reverse the order of declarations, we get a compilation error, because <code>b</code> has not yet been defined.</p>
<div class="play">
    <div class="input">
        <textarea id="src54" rows="7" spellcheck="false">const a = fn() {
    return b()
}
const b = fn() {
    return 42
}
println(a())</textarea>
    </div>
    <div class="output"><pre id="result54"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src54', 'result54');">Run</button>
    </div>
</div>

<p>It is often the case that we need to allow for forward references like the one above. Golem provides a feature called ‘Named Functions’ that offers this functionality. Named functions are declared at the beginning of a given scope. For example:</p>
<div class="play">
    <div class="input">
        <textarea id="src55" rows="7" spellcheck="false">fn a() {
    return b()
}
fn b() {
    return 42
}
assert(a() == 42)</textarea>
    </div>
    <div class="output"><pre id="result55"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src55', 'result55');">Run</button>
    </div>
</div>

<p>This example works because both <code>a</code> and <code>b</code> are declared “simultaneously” at the beginning of the program, before any other declarations are processed by the compiler. Note that the above program is identical in every way to the previous one, except for the forward references provided by the named function syntax.</p>
<p>Named functions are often times just easier to read as well. It is considering idiomatic in Golem to use named functions even when it is not strictly necessary.</p>
<h3 id="closures">Closures</h3>
<p>Golem supports <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a> as well.</p>
<p>Here is an example of a closure that acts as a <a href="http://www.paulgraham.com/accgen.html">accumulator generator</a>:</p>
<div class="play">
    <div class="input">
        <textarea id="src56" rows="7" spellcheck="false">fn foo(n) {
    return fn(i) {
        return n += i
    } 
}
let f = foo(4)
println([f(1), f(2), f(3)])</textarea>
    </div>
    <div class="output"><pre id="result56"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src56', 'result56');">Run</button>
    </div>
</div>

<p>Closures are a fundamental mechanism in Golem for managing state. We will have more to say about closures <a href="#merging-structs">later on</a> in the tour.</p>
<h3 id="optional-parameters">Optional Parameters</h3>
<p>Functions can be declared with optional parameters as well. In the following example, the <code>y</code> parameter defaults to 0 unless the function is invoked with two parameters:</p>
<div class="play">
    <div class="input">
        <textarea id="src57" rows="6" spellcheck="false">fn a(x, y = 0) {
    return x + y
}

println(a(1))
println(a(1, 2))</textarea>
    </div>
    <div class="output"><pre id="result57"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src57', 'result57');">Run</button>
    </div>
</div>

<h3 id="variadic-functions">Variadic Functions</h3>
<p>Functions can also be declared with ‘variadic’ parameters. <code>println</code> is actually a variadic function – it will accept any number of parameters:</p>
<div class="play">
    <div class="input">
        <textarea id="src58" rows="1" spellcheck="false">println(&#39;frog&#39;, &#39;cow&#39;, &#39;rabbit&#39;)</textarea>
    </div>
    <div class="output"><pre id="result58"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src58', 'result58');">Run</button>
    </div>
</div>

<p>Use an ellipsis (three dots) to declare a variadic parameter:</p>
<div class="play">
    <div class="input">
        <textarea id="src59" rows="6" spellcheck="false">fn a(x, ls...) {
    ls.map(|e| =&gt; e + x)
}
println(a(1))
println(a(1, 2))
println(a(1, 2, 3))</textarea>
    </div>
    <div class="output"><pre id="result59"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src59', 'result59');">Run</button>
    </div>
</div>

<p>The “extra” parameters are gathered together into a list. A variadic parameter must always be the last formal parameter. Also, you cannot mix optional parameters and variadic parameters in a declaration.</p>
<h3 id="arity">Arity</h3>
<p>There is a builtin function called <a href="builtins.html#arity">arity</a> that returns a <a href="#structs">struct</a> that describes the <a href="https://en.wikipedia.org/wiki/Arity">arity</a> of a function. Here is a program that prints the arity of 3 of the builtin functions we have already used:</p>
<div class="play">
    <div class="input">
        <textarea id="src60" rows="3" spellcheck="false">println(arity(len))
println(arity(range))
println(arity(println))</textarea>
    </div>
    <div class="output"><pre id="result60"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src60', 'result60');">Run</button>
    </div>
</div>

<h2 id="structs">Structs</h2>
<p>Golem is not an object-oriented language. It does not have classes, objects, inheritance, or constructors. What it does have, however, are values which we call <a href="struct.html">Structs</a>.</p>
<h3 id="struct-syntax">Struct Syntax</h3>
<p>Structs are created via the <code>struct</code> keyword.</p>
<div class="play">
    <div class="input">
        <textarea id="src61" rows="2" spellcheck="false">let s = struct { a: 1, b: 2 }
println(s)</textarea>
    </div>
    <div class="output"><pre id="result61"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src61', 'result61');">Run</button>
    </div>
</div>

<p>In the above example, we’ve created a struct that has two fields, <code>a</code> and <code>b</code>. Remember that a “field” in Golem is a named member of a value. Structs are values that have an arbitrary collection of fields.</p>
<p>Structs are similar to dicts in some ways, but quite different in others. The field names of a struct can only be strings, and furthermore they must be valid identifiers – they cannot have spaces or special characters.</p>
<p>The dot operator, <code>.</code>, is used on structs to get or set the fields of a struct:</p>
<div class="play">
    <div class="input">
        <textarea id="src62" rows="4" spellcheck="false">let s = struct { a: 1, b: 2 }
println(s)
s.a = 3
println(s)</textarea>
    </div>
    <div class="output"><pre id="result62"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src62', 'result62');">Run</button>
    </div>
</div>

<p>Once a struct is created, it cannot have new fields added to it, or existing fields removed. The <em>values</em> associated with the fields can be changed though, as we saw in the previous example.</p>
<p>The <code>this</code> keyword is used in Golem to allow a struct to refer to itself. In Golem, <code>this</code> is only valid inside a struct, and it is always lexically scoped to refer to the innermost enclosing struct.</p>
<div class="play">
    <div class="input">
        <textarea id="src63" rows="2" spellcheck="false">let s = struct { a: 1, b: 2, c: this.a + this.b }
println(s)</textarea>
    </div>
    <div class="output"><pre id="result63"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src63', 'result63');">Run</button>
    </div>
</div>

<h3 id="properties">Properties</h3>
<p>Structs can have properties defined on them, so that a given field has a ‘getter’ function, and optional ‘setter’ function. The getter function must take 0 parameters, and the setter function must take 1 parameter. If the setter function is omitted, the property is readonly. Properties are useful for hiding the inner workings of a struct behind a simpler facade. Here is an example (which uses <a href="#errors">try-catch</a>):</p>
<div class="play">
    <div class="input">
        <textarea id="src64" rows="25" spellcheck="false">let x = 2
let s = struct {

    // &#39;a&#39; is a readonly property with a getter function.
    a: prop { || =&gt; 1 },

    // &#39;b&#39; is a property with getter and setters functions.
    b: prop { || =&gt; x, |v| =&gt; x = v },

    // &#39;a&#39; and &#39;b&#39; act like normal fields here.
    c: || =&gt; this.a + this.b
}

try {
    s.a = 42
    assert(false) // we will never get here.
} catch e {
    println(e.error)
}

println([s.a, s.b, x, s.c()])
s.b = 3
println([s.a, s.b, x, s.c()])
x = 4
println([s.a, s.b, x, s.c()])</textarea>
    </div>
    <div class="output"><pre id="result64"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src64', 'result64');">Run</button>
    </div>
</div>

<h3 id="merging-structs">Merging Structs</h3>
<p>The builtin-function <code>merge()</code> can be used to combine an arbitrary number of existing structs into a new struct.</p>
<div class="play">
    <div class="input">
        <textarea id="src65" rows="13" spellcheck="false">let a = struct { x: 1, y: 2 }
let b = struct { y: 3, z: 4 }
let c = merge(a, b)

println(a)
println(b)
println(c)

a.x = 10

println(a)
println(b)
println(c) // x is changed here too!</textarea>
    </div>
    <div class="output"><pre id="result65"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src65', 'result65');">Run</button>
    </div>
</div>

<p>If there are any duplicated keys in the structs passed in to ‘merge()’, then the value associated with the first such key is used.</p>
<p>Also, note in the above example that if you change a value in one of the structs passed in to merge(), the value changes in the merged struct as well. That is because the all three structs actually share a common set of fields. We will see in the next section that this behaviour can be quite useful.</p>
<h3 id="using-structs-to-build-complex-values">Using Structs to build complex values</h3>
<p>By using structs, closures, and <code>merge()</code> together, it is possible to simulate various features from other languages, including inheritance, multiple-inheritance, prototype chains, and the like.</p>
<p>For instance, consider the following program:</p>
<div class="play">
    <div class="input">
        <textarea id="src66" rows="23" spellcheck="false">fn newRectangle(w, h) {
    return struct {
        width:  prop { || =&gt; w, |val| =&gt; w = val },
        height: prop { || =&gt; h, |val| =&gt; h = val },
        area:   || =&gt; w * h
    }
}

fn newBox(rect, d) {
    return merge(
        rect, 
        struct {
            depth:  prop { || =&gt; d, |val| =&gt; d = val },
            volume: || =&gt; rect.area() * d
        })
}

let r = newRectangle(2, 3)
let b = newBox(r, 4)

println([b.width, b.height, b.depth, b.area(), b.volume()])
r.width = 5
println([b.width, b.height, b.depth, b.area(), b.volume()])</textarea>
    </div>
    <div class="output"><pre id="result66"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src66', 'result66');">Run</button>
    </div>
</div>

<p>The functions <code>newRectangle</code> and <code>newBox</code> are very much like what one might call “constructors” in another language. The structs that they return have functions as entries (e.g. <code>area()</code>), and these functions refer to captured variables (<code>w</code>, <code>h</code>, and <code>d</code>) that are somewhat like member variables of a class. As such, the functions are quite a bit like what one might call a “method” in another language.</p>
<p>The use of the <code>merge()</code> function to create a box out of a rectangle is similar to how inheritance is used in other languages. Does that mean that a Box is a subclass of a Rectangle? Not really, no. There is no such thing as a “class” in Golem. However, due to the behaviour of merge(), they <em>are</em> inter-related in a way that is very much like inheritance.</p>
<p>One of the primary goals of the Golem project is to explore the power provided by the simple building blocks of functions, closures, structs and merge(). It is hoped that the simplicity and flexibility of these elements can be used to create a variety of complex runtime structures that are easy to reason about and use.</p>
<h2 id="errors">Errors</h2>
<p>Golem uses the familiar ’try-catch-finally` syntax that exists in many C-family languages.</p>
<div class="play">
    <div class="input">
        <textarea id="src67" rows="7" spellcheck="false">try {
    let z = 4 / 0
}
catch e {
    println(e.error) 
    println(e.stackTrace) 
}</textarea>
    </div>
    <div class="output"><pre id="result67"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src67', 'result67');">Run</button>
    </div>
</div>

<p>The error value in a <code>catch</code> clause is always a struct with an <code>error</code> field and a <code>stackTrace</code> field.</p>
<p>You can throw an exception using the <code>throw</code> keyword, followed by an expression that evaluates to a string.</p>
<div class="play">
    <div class="input">
        <textarea id="src68" rows="7" spellcheck="false">try {
    throw &#39;FooError: foo&#39;
}
catch e {
    println(e.error) 
    println(e.stackTrace) 
}</textarea>
    </div>
    <div class="output"><pre id="result68"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src68', 'result68');">Run</button>
    </div>
</div>

<p>There is also a <code>finally</code> clause, which is always executed no matter what happens inside the try block or catch clause:</p>
<div class="play">
    <div class="input">
        <textarea id="src69" rows="10" spellcheck="false">try {
    throw &#39;FooError: foo&#39;
}
catch e {
    println(e.error) 
    println(e.stackTrace) 
}
finally {
    println(&#39;finally&#39;)
}</textarea>
    </div>
    <div class="output"><pre id="result69"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src69', 'result69');">Run</button>
    </div>
</div>

<p>A try block must always have either a catch clause, a try clause, or both.</p>
<p>Try statements can be nested, and errors that are not caught in a function are passed upwards in the call stack.</p>
<h2 id="concurrency">Concurrency</h2>
<p>Golem uses the Go Language’s <a href="https://tour.golang.org/concurrency/1">concurrency system</a>. This means that Golem has ‘goroutines’, channels and the ability to send and receive messages.</p>
<div class="play">
    <div class="input">
        <textarea id="src70" rows="13" spellcheck="false">fn sum(s, c) {
    c.send(s.reduce(0, |acc, x| =&gt; acc+x))
}

let s = [7, 2, 8, -9, 4, 0]
let n = len(s)/2
let c = chan()

go sum(s[:n], c)
go sum(s[n:], c)

let result = [c.recv(), c.recv()]
println(result)</textarea>
    </div>
    <div class="output"><pre id="result70"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src70', 'result70');">Run</button>
    </div>
</div>

<p>Golem’s concurrency is not finished yet. In the near future it will be enhanced with the <code>select</code> keyword, the ability to range over a channel, and various pieces of functionality from Go’s <code>sync</code> package.</p>
<h2 id="immutability">Immutability</h2>
<p>Golem supports immutability via the <a href="builtins.html#freeze"><code>freeze</code></a> builtin function, which makes a mutable value become immutable. You can check if a value is immutable via the <a href="builtins.html#frozen"><code>frozen</code></a> builtin function. <code>freeze()</code> always returns the value that you pass into it.</p>
<div class="play">
    <div class="input">
        <textarea id="src71" rows="9" spellcheck="false">let s = freeze(struct { a: 1, b: 2 })
println(frozen(s))

try {
    s.a = 0;       // This will throw an error.
    assert(false); // We can&#39;t reach this statement.
} catch e {
    println(e.error)
}</textarea>
    </div>
    <div class="output"><pre id="result71"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src71', 'result71');">Run</button>
    </div>
</div>

<p><code>freeze()</code> only has an effect on Lists, Dicts, Sets and Structs. All other values are already immutable, so calling <code>freeze()</code> on them has no effect</p>
<p>Immutabilty and concurrency go hand in hand. By using immutable values whenever possible, you can reduce the likelyhood of bugs in your concurrency code, and make it much easier to reason about as well.</p>
<p>An important caveat regarding immutability is that although closures, like all functions, are immutable, they can still have enclosed state that can be modified. There is no way in Golem to freeze a closure after the fact so that it can no longer modify any of its captured variables. It is up to you to manage state properly if you are using closures.</p>
<h2 id="introspection">Introspection</h2>
<p>There is a builtin function called <a href="builtins.html#type"><code>type</code></a> that will return a string describing the type of a value. Here is a program that will print a list of every possible type:</p>
<div class="play">
    <div class="input">
        <textarea id="src72" rows="5" spellcheck="false">let values = [
    null, true, &quot;&quot;, 0, 0.0, fn(){}, 
    [], range(0,1), (0,1), dict{}, set{}, 
    struct{}, chan()]
println(values.map(type))</textarea>
    </div>
    <div class="output"><pre id="result72"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src72', 'result72');">Run</button>
    </div>
</div>

<p>There is another builtin function called <a href="builtins.html#fields"><code>fields</code></a> that will return the set of all fields belonging to a given value. There is also <a href="builtins.html#has"><code>has</code></a>, which returns whether a value has a given field:</p>
<div class="play">
    <div class="input">
        <textarea id="src73" rows="3" spellcheck="false">let s = struct { a: 1, b: 2 }
println(fields(s))
println([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].map(|e| =&gt; has(s, e)))</textarea>
    </div>
    <div class="output"><pre id="result73"></pre></div>
    <div class="buttons">
        <button class="button" onClick="interpret('src73', 'result73');">Run</button>
    </div>
</div>

<h2 id="command-line-executable">Command Line Executable</h2>
<p>Thus far, we have been running Golem in the browser via the magic of <a href="https://github.com/golang/go/wiki/WebAssembly">WebAssembly</a>.</p>
<p>It is also possible to run Golem from the command line as an executable (and via many <a href="#embedding">other routes</a> as well).</p>
<p>To do this, you must first compile a version of the Golem. This requires that you have the Go language toolchain installed on your system, with at least version 1.9.</p>
<p>Clone the Golem <a href="https://github.com/mjarmy/golem-lang">repository</a> into the proper place in your go development environment, <code>cd</code> into the top level directory of the repo, and type <code>make</code>. This will build Golem, and place the <code>golem</code> executable in a sub-directory called <code>build</code>.</p>
<p>Then, fire up your <a href="https://github.com/mjarmy/golem-lang/wiki/IDE-Support">IDE</a> of choice, and type the Golem code of your choice into a file named “tour.glm”, and run it like so: <code>./build/golem tour.glm</code>.</p>
<h3 id="modules">Modules</h3>
<p>In addition to supporting all of the builtin functions that we have seen so far, the <code>golem</code> executable supports a new concept called “modules”.</p>
<p>The Golem CLI actually compiles the “tour.glm” file that you made eariler into a <code>module</code> called “tour”. Modules are the fundamental unit of compilation in Golem, and are also used for namespace management.</p>
<p>All you need to do to create your own modules that the <code>golem</code> executable can use is create a file with the name you want. As an example, lets create a module called foo, and reference in the tour module.</p>
<p>In a file called “foo.glm”, place the following:</p>
<pre class="nowasm"><code>fn square(x) {
    return x*x
}</code></pre>
<p>And then in your “tour.glm”, you can reference the “foo” module via the <code>import</code> statement, like this:</p>
<pre class="nowasm"><code>import foo
assert(foo.square(5) == 25)</code></pre>
<h3 id="the-main-function">The <code>main()</code> Function</h3>
<p>You can pass arguments into a Golem CLI program by defining a <code>main()</code> function, that accepts exactly one parameter. The parameter will always be a list of the command line arguments.</p>
<pre class="nowasm"><code>fn main(args) {
    for i in range(0, len(args)) {
        println(&#39;argument &#39;, i, &#39; is &quot;&#39;, args[i], &#39;&quot;&#39;)
    }
}</code></pre>
<h3 id="standard-library">Standard Library</h3>
<p>Golem has a <a href="http://localhost:8080/reference.html#standard-library">Standard Library</a> that is implemented as a collection of modules. The standard library is based primarily on Go’s standard library.</p>
<p>Golem’s standard library is rather small at this time – one of the major pieces of work still to be done is to build out the library.</p>
<p>When embedding the Golem interpreter in a Go program, some or all of the standard library can be included in the sandboxed environment. The <code>golem</code> executable makes the entire standard library available.</p>
<p>To use one of the modules from the standard library, simply import it like you would any module, e.g. <code>import os</code>.</p>
<h3 id="examples">Examples</h3>
<p>In the Golem github repo, there are a couple of good examples of substantial programs that can be run via the <code>golem</code> executable.</p>
<p>First, there is the Golem program that creates the static web site that you are reading right now:</p>
<p><a href="https://github.com/mjarmy/golem-lang/blob/master/tools/docs/makeDocs.glm" class="uri">https://github.com/mjarmy/golem-lang/blob/master/tools/docs/makeDocs.glm</a></p>
<p>And second, there is a large program in the bench_test directory that allows Golem to test itself as part of the build process:</p>
<p><a href="https://github.com/mjarmy/golem-lang/blob/master/bench_test/core_test.glm" class="uri">https://github.com/mjarmy/golem-lang/blob/master/bench_test/core_test.glm</a></p>
<h2 id="embedding">Embedding</h2>
<p>So far, we have seen Golem in action in two contexts: as a <a href="https://github.com/mjarmy/golem-lang/blob/master/tools/docs/wasm.go">WebAssembly</a> executable, and a <a href="https://github.com/mjarmy/golem-lang/blob/master/cli/golem.go">command line</a> executable.</p>
<p>Golem is easy to embed in a Go program in other ways though. If you are interested in learning more about how to embed Golem in Go, please head over to the <a href="embedding.html">Embedding</a> document.</p>


            <p><small><em>This page uses documentation from <a href="https://github.com/golang/go">Go</a> , which is licensed under the BSD-3-Clause license.</em></small>
        </div>
    </body>
</html>
